From 46925c584f636c73136da1e79863079f1256316f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Wed, 5 Aug 2020 16:07:16 +0200
Subject: [PATCH 01/23] rotateinfo: Fix indentation
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/rotateinfo.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/rotateinfo.c b/src/rotateinfo.c
index 5cd3ccf7..b673fa3d 100644
--- a/src/rotateinfo.c
+++ b/src/rotateinfo.c
@@ -59,7 +59,7 @@ set_state (PhoshRotateInfo *self)
   monitor_is_landscape = ((double)monitor->width / (double)monitor->height) > 1.0;
   portrait = monitor_is_landscape ? !portrait : portrait;
 
-  g_debug ("Potrait: %d, width: %d, height: %d", portrait, monitor->width , monitor->height);
+  g_debug ("Potrait: %d, width: %d, height: %d", portrait, monitor->width, monitor->height);
   if (portrait) {
     phosh_status_icon_set_icon_name (PHOSH_STATUS_ICON (self), "screen-rotation-portrait-symbolic");
     phosh_status_icon_set_info (PHOSH_STATUS_ICON (self), _("Portrait"));
-- 
GitLab


From e82f9cda6258308b3b8948e97cef1f96f6e49bf4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Fri, 26 Mar 2021 09:37:13 +0100
Subject: [PATCH 02/23] monitor-manager: Fix doc string
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Make function name match the actual definition.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/monitor-manager.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/monitor-manager.c b/src/monitor-manager.c
index d67f073b..6e48ce26 100644
--- a/src/monitor-manager.c
+++ b/src/monitor-manager.c
@@ -1369,9 +1369,10 @@ phosh_monitor_manager_get_num_monitors (PhoshMonitorManager *self)
 }
 
 /**
- * phosh_monitor_set_transform:
+ * phosh_monitor_manager_set_monitor_transform:
  * @self: A #PhoshMonitor
- * @mode: The #PhoshMonitorPowerSaveMode
+ * @monitor: The #PhoshMonitor to set the tansform on
+ * @transform: The #PhoshMonitorTransform to set
  *
  * Sets monitor's transform. This will become active after the next
  * call to #phosh_monitor_manager_apply_monitor_config().
-- 
GitLab


From dcfcc3733864f232be575b52f4cfd41ea43b247c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Wed, 31 Mar 2021 10:14:26 +0200
Subject: [PATCH 03/23] torch: Make debug statement more useful
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We want to what things changed not only that s.th. happened.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/torch-info.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/torch-info.c b/src/torch-info.c
index 21617e21..1dbec341 100644
--- a/src/torch-info.c
+++ b/src/torch-info.c
@@ -87,7 +87,6 @@ on_torch_enabled (PhoshTorchInfo *self, GParamSpec *pspec, PhoshTorchManager *to
 {
   gboolean enabled;
 
-  g_debug ("Updating torch status");
   g_return_if_fail (PHOSH_IS_TORCH_INFO (self));
   g_return_if_fail (PHOSH_IS_TORCH_MANAGER (torch));
 
@@ -96,6 +95,8 @@ on_torch_enabled (PhoshTorchInfo *self, GParamSpec *pspec, PhoshTorchManager *to
     return;
 
   self->enabled = enabled;
+  g_debug ("Updating torch enabled: %d", enabled);
+
   g_object_notify_by_pspec (G_OBJECT (self), props[PROP_ENABLED]);
 }
 
-- 
GitLab


From 663443a247d34ac1f4c565ebff50b8c1aff27d97 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Wed, 31 Mar 2021 10:17:47 +0200
Subject: [PATCH 04/23] proximity: Handle NULL builtin monitor
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

There might be no builtin monitor at all or it could be disabled.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/proximity.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/proximity.c b/src/proximity.c
index a4e15a7c..4e6a2870 100644
--- a/src/proximity.c
+++ b/src/proximity.c
@@ -148,15 +148,15 @@ on_proximity_near_changed (PhoshProximity          *self,
                            PhoshSensorProxyManager *sensor)
 {
   gboolean near;
+  PhoshShell *shell = phosh_shell_get_default ();
+  PhoshMonitor *monitor = phosh_shell_get_builtin_monitor (shell);
 
   near = phosh_dbus_sensor_proxy_get_proximity_near (
     PHOSH_DBUS_SENSOR_PROXY (self->sensor_proxy_manager));
 
   g_debug ("Proximity near changed: %d", near);
-  if (near) {
-    PhoshShell *shell = phosh_shell_get_default ();
+  if (near && monitor) {
     PhoshWayland *wl = phosh_wayland_get_default ();
-    PhoshMonitor *monitor = phosh_shell_get_builtin_monitor (shell);
 
     if (!self->fader) {
       self->fader = phosh_fader_new (phosh_wayland_get_zwlr_layer_shell_v1 (wl),
-- 
GitLab


From ea4e5172c76ca8722ab0b135d7abf791ee5a5131 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Thu, 7 Jan 2021 16:39:12 +0100
Subject: [PATCH 05/23] shell: Create sensor-manager early
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We want that before the panels since those might use other
managers that need the sensor-manager (e.g. rotation-manager)

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/shell.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/shell.c b/src/shell.c
index 0aad5403..cb596b45 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -469,6 +469,8 @@ setup_idle_cb (PhoshShell *self)
   priv->session_manager = phosh_session_manager_new ();
   priv->mode_manager = phosh_mode_manager_new ();
 
+  priv->sensor_proxy_manager = phosh_sensor_proxy_manager_get_default_failable ();
+
   panels_create (self);
   /* Create background after panel since it needs the panel's size */
   priv->background_manager = phosh_background_manager_new ();
@@ -502,8 +504,8 @@ setup_idle_cb (PhoshShell *self)
   if (priv->sensor_proxy_manager) {
     priv->proximity = phosh_proximity_new (priv->sensor_proxy_manager,
                                            priv->lockscreen_manager);
-    /* TODO: accelerometer */
   }
+
   priv->mount_manager = phosh_mount_manager_new ();
 
   phosh_session_manager_register (priv->session_manager,
-- 
GitLab


From 24dc021e1c928cd3e0e54e4c286fd529ad4cf20e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Thu, 7 Jan 2021 16:36:12 +0100
Subject: [PATCH 06/23] shell: Don't bother with accelerometer
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Rotation-manager takes care of that

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/shell.c | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/src/shell.c b/src/shell.c
index cb596b45..0bcf6558 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -340,13 +340,6 @@ phosh_shell_dispose (GObject *object)
   PhoshShell *self = PHOSH_SHELL (object);
   PhoshShellPrivate *priv = phosh_shell_get_instance_private(self);
 
-  if (priv->sensor_proxy_manager) {
-    phosh_dbus_sensor_proxy_call_release_accelerometer_sync (
-      PHOSH_DBUS_SENSOR_PROXY(priv->sensor_proxy_manager),
-      NULL, NULL);
-      g_clear_object (&priv->sensor_proxy_manager);
-  }
-
   panels_dispose (self);
   g_clear_pointer (&priv->faders, g_ptr_array_unref);
 
-- 
GitLab


From 23ae71f80dc5d4bd4f80f1d0edccac97a9ee868e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Thu, 7 Jan 2021 20:32:06 +0100
Subject: [PATCH 07/23] shell: Decruft builtin monitor setup
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Just look it up on start since it can't change.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/shell.c | 45 +++++++++++++++++++++++++++++----------------
 1 file changed, 29 insertions(+), 16 deletions(-)

diff --git a/src/shell.c b/src/shell.c
index 0bcf6558..b8a71053 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -611,6 +611,32 @@ on_monitor_removed (PhoshShell *self, PhoshMonitor *monitor)
 }
 
 
+static PhoshMonitor *
+find_builtin_monitor (PhoshShell *self)
+{
+  PhoshShellPrivate *priv;
+  PhoshMonitor *monitor = NULL;
+
+  g_return_val_if_fail (PHOSH_IS_SHELL (self), NULL);
+  priv = phosh_shell_get_instance_private (self);
+
+  if (priv->builtin_monitor)
+    return priv->builtin_monitor;
+
+  for (int i = 0; i < phosh_monitor_manager_get_num_monitors (priv->monitor_manager); i++) {
+    monitor = phosh_monitor_manager_get_monitor (priv->monitor_manager, i);
+    if (phosh_monitor_is_builtin (monitor))
+      break;
+  }
+
+  if (!monitor)
+    monitor = phosh_monitor_manager_get_monitor (priv->monitor_manager, 0);
+  g_return_val_if_fail (monitor, NULL);
+
+  return monitor;
+}
+
+
 static void
 phosh_shell_constructed (GObject *object)
 {
@@ -634,7 +660,7 @@ phosh_shell_constructed (GObject *object)
   phosh_wayland_roundtrip (phosh_wayland_get_default ());
 
   if (phosh_monitor_manager_get_num_monitors(priv->monitor_manager)) {
-    priv->builtin_monitor = phosh_shell_get_builtin_monitor (self);
+    priv->builtin_monitor = g_object_ref (find_builtin_monitor (self));
 
     g_debug ("Builtin monitor is %s, %d", priv->builtin_monitor->name,
              phosh_monitor_is_configured (priv->builtin_monitor));
@@ -819,25 +845,12 @@ PhoshMonitor *
 phosh_shell_get_builtin_monitor (PhoshShell *self)
 {
   PhoshShellPrivate *priv;
-  PhoshMonitor *monitor = NULL;
 
   g_return_val_if_fail (PHOSH_IS_SHELL (self), NULL);
   priv = phosh_shell_get_instance_private (self);
+  g_return_val_if_fail (PHOSH_IS_MONITOR (priv->builtin_monitor), NULL);
 
-  if (priv->builtin_monitor)
-    return priv->builtin_monitor;
-
-  for (int i = 0; i < phosh_monitor_manager_get_num_monitors (priv->monitor_manager); i++) {
-    monitor = phosh_monitor_manager_get_monitor (priv->monitor_manager, i);
-    if (phosh_monitor_is_builtin (monitor))
-      break;
-  }
-
-  if (!monitor)
-    monitor = phosh_monitor_manager_get_monitor (priv->monitor_manager, 0);
-  g_return_val_if_fail (monitor, NULL);
-
-  return monitor;
+  return priv->builtin_monitor;
 }
 
 
-- 
GitLab


From 973da32ab84c5c7937d7c1a58d06ef919a75bf0d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Mon, 29 Mar 2021 17:51:52 +0200
Subject: [PATCH 08/23] Avoid sensor-proxy singleton

Treat it as regular initable that is fetched from the shell
like other managers.
---
 src/sensor-proxy-manager.c | 30 ++++++++----------------------
 src/sensor-proxy-manager.h |  2 +-
 src/shell.c                |  6 ++++--
 3 files changed, 13 insertions(+), 25 deletions(-)

diff --git a/src/sensor-proxy-manager.c b/src/sensor-proxy-manager.c
index 89b5e8f1..473a6b21 100644
--- a/src/sensor-proxy-manager.c
+++ b/src/sensor-proxy-manager.c
@@ -52,27 +52,13 @@ phosh_sensor_proxy_manager_init (PhoshSensorProxyManager *self)
 
 
 PhoshSensorProxyManager *
-phosh_sensor_proxy_manager_get_default_failable (void)
+phosh_sensor_proxy_manager_new (GError **err)
 {
-  static PhoshSensorProxyManager *instance;
-  GError *err = NULL;
-  GInitable *ret;
-
-  if (instance == NULL) {
-    ret = g_initable_new (PHOSH_TYPE_SENSOR_PROXY_MANAGER, NULL, &err,
-                          "g-flags", G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,
-                          "g-name", IIO_SENSOR_PROXY_DBUS_NAME,
-                          "g-bus-type", G_BUS_TYPE_SYSTEM,
-                          "g-object-path", IIO_SENSOR_PROXY_DBUS_OBJECT,
-                          "g-interface-name", IIO_SENSOR_PROXY_DBUS_IFACE_NAME,
-                          NULL);
-    if (ret != NULL) {
-      instance = PHOSH_SENSOR_PROXY_MANAGER (ret);
-    } else {
-      g_warning ("Can't connect to iio-sensor-sensor proxy:  %s", err->message);
-      return NULL;
-    }
-    g_object_add_weak_pointer (G_OBJECT (instance), (gpointer *)&instance);
-  }
-  return instance;
+  return g_initable_new (PHOSH_TYPE_SENSOR_PROXY_MANAGER, NULL, err,
+                         "g-flags", G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,
+                         "g-name", IIO_SENSOR_PROXY_DBUS_NAME,
+                         "g-bus-type", G_BUS_TYPE_SYSTEM,
+                         "g-object-path", IIO_SENSOR_PROXY_DBUS_OBJECT,
+                         "g-interface-name", IIO_SENSOR_PROXY_DBUS_IFACE_NAME,
+                         NULL);
 }
diff --git a/src/sensor-proxy-manager.h b/src/sensor-proxy-manager.h
index 9d140bae..32664a6d 100644
--- a/src/sensor-proxy-manager.h
+++ b/src/sensor-proxy-manager.h
@@ -13,6 +13,6 @@
 G_DECLARE_FINAL_TYPE (PhoshSensorProxyManager, phosh_sensor_proxy_manager,
                       PHOSH, SENSOR_PROXY_MANAGER, PhoshDBusSensorProxyProxy)
 
-PhoshSensorProxyManager *phosh_sensor_proxy_manager_get_default_failable (void);
+PhoshSensorProxyManager *phosh_sensor_proxy_manager_new (GError **err);
 gboolean phosh_sensor_proxy_manager_claim_proximity_sync (PhoshSensorProxyManager *self,
                                                           GError **err);
diff --git a/src/shell.c b/src/shell.c
index b8a71053..6f0d3663 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -457,12 +457,15 @@ on_fade_out_timeout (PhoshShell *self)
 static gboolean
 setup_idle_cb (PhoshShell *self)
 {
+  g_autoptr (GError) err = NULL;
   PhoshShellPrivate *priv = phosh_shell_get_instance_private (self);
 
   priv->session_manager = phosh_session_manager_new ();
   priv->mode_manager = phosh_mode_manager_new ();
 
-  priv->sensor_proxy_manager = phosh_sensor_proxy_manager_get_default_failable ();
+  priv->sensor_proxy_manager = phosh_sensor_proxy_manager_new (&err);
+  if (!priv->sensor_proxy_manager)
+    g_warning ("Failed to connect to sensor-proxy: %s", err->message);
 
   panels_create (self);
   /* Create background after panel since it needs the panel's size */
@@ -493,7 +496,6 @@ setup_idle_cb (PhoshShell *self)
                            G_CONNECT_SWAPPED);
 
   priv->location_manager = phosh_location_manager_new ();
-  priv->sensor_proxy_manager = phosh_sensor_proxy_manager_get_default_failable ();
   if (priv->sensor_proxy_manager) {
     priv->proximity = phosh_proximity_new (priv->sensor_proxy_manager,
                                            priv->lockscreen_manager);
-- 
GitLab


From f121e0a9520d8a0e8bd0a1c8beef7cfc16bfb280 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Tue, 23 Jun 2020 14:05:57 +0200
Subject: [PATCH 09/23] Add rotation-manager
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The rotation manager listens to device orientation changes
and adjusts the primary display accordingly.

This interfaces with lockscreen, iio-sensor-proxy and
gsettings to figure out the correct screen orientation.

The manager has two modes: off (don't rotate any output) and sensor
(adjust due to sensor values).

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 docs/phosh-docs.xml    |   1 +
 src/meson.build        |   3 +
 src/phosh-enums.c.in   |   1 +
 src/rotation-manager.c | 546 +++++++++++++++++++++++++++++++++++++++++
 src/rotation-manager.h |  45 ++++
 src/shell.c            |  22 ++
 src/shell.h            |   2 +
 7 files changed, 620 insertions(+)
 create mode 100644 src/rotation-manager.c
 create mode 100644 src/rotation-manager.h

diff --git a/docs/phosh-docs.xml b/docs/phosh-docs.xml
index e6c0a9db..9900a4ae 100644
--- a/docs/phosh-docs.xml
+++ b/docs/phosh-docs.xml
@@ -102,6 +102,7 @@
       <xi:include href="xml/proximity.xml"/>
       <xi:include href="xml/quick-setting.xml"/>
       <xi:include href="xml/rotateinfo.xml"/>
+      <xi:include href="xml/rotation-manager.xml"/>
       <xi:include href="xml/screen-saver-manager.xml"/>
       <xi:include href="xml/sensor-proxy-manager.xml"/>
       <xi:include href="xml/session-manager.xml"/>
diff --git a/src/meson.build b/src/meson.build
index 7935b17a..5a0ea2b3 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -23,6 +23,7 @@ phosh_enum_headers = [
   'notifications/notification.h',
   'notifications/notify-manager.h',
   'phosh-wayland.h',
+  'rotation-manager.h',
   'shell.h',
 ] + schema_enum_headers
 
@@ -162,6 +163,8 @@ libphosh_sources = [
   'polkit-auth-prompt.h',
   'proximity.h',
   'proximity.c',
+  'rotation-manager.h',
+  'rotation-manager.c',
   'sensor-proxy-manager.c',
   'sensor-proxy-manager.h',
   'rotateinfo.c',
diff --git a/src/phosh-enums.c.in b/src/phosh-enums.c.in
index f001d726..293b97d9 100644
--- a/src/phosh-enums.c.in
+++ b/src/phosh-enums.c.in
@@ -11,6 +11,7 @@
 #include "notifications/notification.h"
 #include "notifications/notify-manager.h"
 #include "phosh-wayland.h"
+#include "rotation-manager.h"
 #include "shell.h"
 #include "wwan/phosh-wwan-backend.h"
 
diff --git a/src/rotation-manager.c b/src/rotation-manager.c
new file mode 100644
index 00000000..ba847553
--- /dev/null
+++ b/src/rotation-manager.c
@@ -0,0 +1,546 @@
+/*
+ * Copyright (C) 2021 Purism SPC
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ * Author: Guido Günther <agx@sigxcpu.org>
+ */
+
+#define G_LOG_DOMAIN "phosh-rotation-manager"
+
+#include "config.h"
+#include "rotation-manager.h"
+#include "shell.h"
+#include "sensor-proxy-manager.h"
+#include "util.h"
+
+#define ORIENTATION_LOCK_SCHEMA_ID "org.gnome.settings-daemon.peripherals.touchscreen"
+#define ORIENTATION_LOCK_KEY       "orientation-lock"
+
+/**
+ * SECTION:rotation-manager
+ * @short_description: The Rotation Manager
+ * @Title: PhoshRotationManager
+ *
+ * #PhoshRotationManager is responsible for managing the rotation of
+ * a given #PhoshMonitor. Depending on the #PhoshRotationManagerMode
+ * this can happen by interfacing with a #PhoshSensorProxyManager or
+ * by setting the #PhoshMonitorTransform explicitly.
+ * It also takes the #PhoshLockscreenManager:locked status into account
+ * to ensure the lockscreen is rotated accordingly on small phones.
+ */
+
+enum {
+  PROP_0,
+  PROP_SENSOR_PROXY_MANAGER,
+  PROP_LOCKSCREEN_MANAGER,
+  PROP_ORIENTATION_LOCKED,
+  PROP_MONITOR,
+  PROP_MODE,
+  LAST_PROP,
+};
+static GParamSpec *props[LAST_PROP];
+
+typedef struct _PhoshRotationManager {
+  GObject                  parent;
+
+  gboolean                 claimed;
+  PhoshSensorProxyManager *sensor_proxy_manager;
+  PhoshLockscreenManager  *lockscreen_manager;
+  PhoshMonitor            *monitor;
+
+  GSettings               *settings;
+  gboolean                 orientation_locked;
+
+  PhoshRotationManagerMode mode;
+} PhoshRotationManager;
+
+G_DEFINE_TYPE (PhoshRotationManager, phosh_rotation_manager, G_TYPE_OBJECT);
+
+
+static void
+apply_transform (PhoshRotationManager *self, PhoshMonitorTransform transform)
+{
+  PhoshMonitorTransform current;
+  PhoshMonitorManager *monitor_manager = phosh_shell_get_monitor_manager (phosh_shell_get_default());
+
+  g_return_if_fail (PHOSH_IS_MONITOR_MANAGER (monitor_manager));
+  g_return_if_fail (PHOSH_IS_MONITOR (self->monitor));
+
+  g_debug ("Rotating %s: %d", self->monitor->name, transform);
+
+  current = phosh_monitor_get_transform (self->monitor);
+  if (current == transform)
+    return;
+
+  phosh_monitor_manager_set_monitor_transform (monitor_manager,
+                                               self->monitor,
+                                               transform);
+  phosh_monitor_manager_apply_monitor_config (monitor_manager);
+}
+
+/**
+ * match_orientation:
+ * @self: The #PhoshRotationManager
+ *
+ * Match the screen orientation to the sensor output.
+ * Do nothing if orientation lock is on or there's no
+ * sensor claimed.
+ */
+static void
+match_orientation (PhoshRotationManager *self)
+{
+  const gchar *orient;
+  PhoshMonitorTransform transform;
+
+  if (self->orientation_locked || !self->claimed ||
+      self->mode == PHOSH_ROTATION_MANAGER_MODE_OFF)
+    return;
+
+  orient = phosh_dbus_sensor_proxy_get_accelerometer_orientation (
+    PHOSH_DBUS_SENSOR_PROXY (self->sensor_proxy_manager));
+
+  g_debug ("Orientation changed: %s, locked: %d, claimed: %d",
+           orient, self->orientation_locked, self->claimed);
+
+  if (!g_strcmp0 ("normal", orient)) {
+    transform = PHOSH_MONITOR_TRANSFORM_NORMAL;
+  } else if (!g_strcmp0 ("right-up", orient)) {
+    transform = PHOSH_MONITOR_TRANSFORM_90;
+  } else if (!g_strcmp0 ("bottom-up", orient)) {
+    transform = PHOSH_MONITOR_TRANSFORM_180;
+  } else if (!g_strcmp0 ("left-up", orient)) {
+    transform = PHOSH_MONITOR_TRANSFORM_270;
+  } else if (!g_strcmp0 ("undefined", orient)) {
+    return; /* just leave as is */
+  } else {
+    g_warning ("Unknown orientation '%s'", orient);
+    return;
+  }
+
+  apply_transform (self, transform);
+}
+
+static void
+on_accelerometer_claimed (PhoshSensorProxyManager *sensor_proxy_manager,
+                          GAsyncResult            *res,
+                          PhoshRotationManager    *self)
+{
+  g_autoptr (GError) err = NULL;
+  gboolean success;
+
+  g_return_if_fail (PHOSH_IS_SENSOR_PROXY_MANAGER (sensor_proxy_manager));
+  g_return_if_fail (PHOSH_IS_ROTATION_MANAGER (self));
+  g_return_if_fail (sensor_proxy_manager == self->sensor_proxy_manager);
+
+  success = phosh_dbus_sensor_proxy_call_claim_accelerometer_finish (
+    PHOSH_DBUS_SENSOR_PROXY (sensor_proxy_manager),
+    res, &err);
+  if (success) {
+    g_debug ("Claimed accelerometer");
+    self->claimed = TRUE;
+  } else {
+    g_warning ("Failed to claim accelerometer: %s", err->message);
+  }
+  match_orientation (self);
+  g_object_unref (self);
+}
+
+static void
+on_accelerometer_released (PhoshSensorProxyManager *sensor_proxy_manager,
+                           GAsyncResult            *res,
+                           PhoshRotationManager    *self)
+{
+  g_autoptr (GError) err = NULL;
+  gboolean success;
+
+  g_return_if_fail (PHOSH_IS_SENSOR_PROXY_MANAGER (sensor_proxy_manager));
+  g_return_if_fail (PHOSH_IS_ROTATION_MANAGER (self));
+  g_return_if_fail (sensor_proxy_manager == self->sensor_proxy_manager);
+
+  success = phosh_dbus_sensor_proxy_call_release_accelerometer_finish (
+    PHOSH_DBUS_SENSOR_PROXY (sensor_proxy_manager),
+    res, &err);
+  if (success) {
+    g_debug ("Released rotation sensor");
+  } else {
+    g_warning ("Failed to release rotation sensor: %s", err->message);
+  }
+  self->claimed = FALSE;
+  g_object_unref (self);
+}
+
+static void
+phosh_rotation_manager_claim_accelerometer (PhoshRotationManager *self, gboolean claim)
+{
+  if (claim == self->claimed)
+    return;
+
+  if (!self->sensor_proxy_manager)
+    return;
+
+  if (claim) {
+    phosh_dbus_sensor_proxy_call_claim_accelerometer (
+      PHOSH_DBUS_SENSOR_PROXY (self->sensor_proxy_manager),
+      NULL,
+      (GAsyncReadyCallback)on_accelerometer_claimed,
+      g_object_ref (self));
+  } else {
+    phosh_dbus_sensor_proxy_call_release_accelerometer (
+      PHOSH_DBUS_SENSOR_PROXY (self->sensor_proxy_manager),
+      NULL,
+      (GAsyncReadyCallback)on_accelerometer_released,
+      g_object_ref (self));
+  }
+}
+
+static void
+on_has_accelerometer_changed (PhoshRotationManager    *self,
+                              GParamSpec              *pspec,
+                              PhoshSensorProxyManager *proxy)
+{
+  gboolean has_accel;
+  PhoshRotationManagerMode mode;
+
+  has_accel = phosh_dbus_sensor_proxy_get_has_accelerometer (
+    PHOSH_DBUS_SENSOR_PROXY (self->sensor_proxy_manager));
+
+  g_debug ("Found %s accelerometer", has_accel ? "a" : "no");
+
+  mode = has_accel ? PHOSH_ROTATION_MANAGER_MODE_SENSOR : PHOSH_ROTATION_MANAGER_MODE_OFF;
+  phosh_rotation_manager_set_mode (self, mode);
+}
+
+static void
+on_lockscreen_manager_locked (PhoshRotationManager *self, GParamSpec *pspec,
+                              PhoshLockscreenManager *lockscreen_manager)
+{
+  gboolean claim;
+
+  g_return_if_fail (PHOSH_IS_ROTATION_MANAGER (self));
+  g_return_if_fail (PHOSH_IS_LOCKSCREEN_MANAGER (lockscreen_manager));
+
+  if (self->mode == PHOSH_ROTATION_MANAGER_MODE_OFF)
+    claim = FALSE;
+  else
+    claim = !phosh_lockscreen_manager_get_locked (self->lockscreen_manager);
+
+  phosh_rotation_manager_claim_accelerometer (self, claim);
+}
+
+static void
+on_accelerometer_orientation_changed (PhoshRotationManager    *self,
+                                      GParamSpec              *pspec,
+                                      PhoshSensorProxyManager *sensor)
+{
+  g_return_if_fail (PHOSH_IS_ROTATION_MANAGER (self));
+  g_return_if_fail (self->sensor_proxy_manager == sensor);
+
+  match_orientation (self);
+}
+
+static void
+phosh_rotation_manager_set_property (GObject      *object,
+                                     guint         property_id,
+                                     const GValue *value,
+                                     GParamSpec   *pspec)
+{
+  PhoshRotationManager *self = PHOSH_ROTATION_MANAGER (object);
+
+  switch (property_id) {
+  case PROP_SENSOR_PROXY_MANAGER:
+    /* construct only */
+    self->sensor_proxy_manager = g_value_dup_object (value);
+    break;
+  case PROP_LOCKSCREEN_MANAGER:
+    /* construct only */
+    self->lockscreen_manager = g_value_dup_object (value);
+    break;
+  case PROP_MONITOR:
+    /* construct only */
+    self->monitor = g_value_dup_object (value);
+    break;
+  case PROP_ORIENTATION_LOCKED:
+    phosh_rotation_manager_set_orientation_locked (self,
+                                                   g_value_get_boolean (value));
+    break;
+  case PROP_MODE:
+    phosh_rotation_manager_set_mode (self, g_value_get_enum (value));
+    break;
+  default:
+    G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    break;
+  }
+}
+
+static void
+phosh_rotation_manager_get_property (GObject    *object,
+                                     guint       property_id,
+                                     GValue     *value,
+                                     GParamSpec *pspec)
+{
+  PhoshRotationManager *self = PHOSH_ROTATION_MANAGER (object);
+
+  switch (property_id) {
+  case PROP_SENSOR_PROXY_MANAGER:
+    g_value_set_object (value, self->sensor_proxy_manager);
+    break;
+  case PROP_LOCKSCREEN_MANAGER:
+    g_value_set_object (value, self->lockscreen_manager);
+    break;
+  case PROP_ORIENTATION_LOCKED:
+    g_value_set_boolean (value, self->orientation_locked);
+    break;
+  case PROP_MODE:
+    g_value_set_enum (value, self->mode);
+    break;
+  default:
+    G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    break;
+  }
+}
+
+static void
+phosh_rotation_manager_constructed (GObject *object)
+{
+  PhoshRotationManager *self = PHOSH_ROTATION_MANAGER (object);
+
+  G_OBJECT_CLASS (phosh_rotation_manager_parent_class)->constructed (object);
+
+  self->settings = g_settings_new (ORIENTATION_LOCK_SCHEMA_ID);
+
+  g_settings_bind (self->settings,
+                   ORIENTATION_LOCK_KEY,
+                   self,
+                   "orientation-locked",
+                   G_BINDING_SYNC_CREATE
+                   | G_BINDING_BIDIRECTIONAL);
+
+  g_signal_connect_swapped (self->lockscreen_manager,
+                            "notify::locked",
+                            (GCallback) on_lockscreen_manager_locked,
+                            self);
+  on_lockscreen_manager_locked (self, NULL, self->lockscreen_manager);
+
+  if (!self->sensor_proxy_manager)
+    return;
+
+  g_signal_connect_swapped (self->sensor_proxy_manager,
+                            "notify::accelerometer-orientation",
+                            (GCallback) on_accelerometer_orientation_changed,
+                            self);
+
+  g_signal_connect_swapped (self->sensor_proxy_manager,
+                            "notify::has-accelerometer",
+                            (GCallback) on_has_accelerometer_changed,
+                            self);
+  on_has_accelerometer_changed (self, NULL, self->sensor_proxy_manager);
+}
+
+
+static void
+phosh_rotation_manager_dispose (GObject *object)
+{
+  PhoshRotationManager *self = PHOSH_ROTATION_MANAGER (object);
+
+  g_clear_object (&self->settings);
+
+  if (self->sensor_proxy_manager) {
+    g_signal_handlers_disconnect_by_data (self->sensor_proxy_manager,
+                                          self);
+    /* Sync call since we're going away */
+    phosh_dbus_sensor_proxy_call_release_accelerometer_sync (
+      PHOSH_DBUS_SENSOR_PROXY (self->sensor_proxy_manager), NULL, NULL);
+    g_clear_object (&self->sensor_proxy_manager);
+  }
+
+  if (self->lockscreen_manager) {
+    g_signal_handlers_disconnect_by_data (self->lockscreen_manager,
+                                          self);
+    g_clear_object (&self->lockscreen_manager);
+  }
+  g_clear_object (&self->monitor);
+
+  G_OBJECT_CLASS (phosh_rotation_manager_parent_class)->dispose (object);
+}
+
+static void
+phosh_rotation_manager_class_init (PhoshRotationManagerClass *klass)
+{
+  GObjectClass *object_class = (GObjectClass *)klass;
+
+  object_class->constructed = phosh_rotation_manager_constructed;
+  object_class->dispose = phosh_rotation_manager_dispose;
+
+  object_class->set_property = phosh_rotation_manager_set_property;
+  object_class->get_property = phosh_rotation_manager_get_property;
+
+  props[PROP_SENSOR_PROXY_MANAGER] =
+    g_param_spec_object (
+      "sensor-proxy-manager",
+      "Sensor proxy manager",
+      "The object inerfacing with iio-sensor-proxy",
+      PHOSH_TYPE_SENSOR_PROXY_MANAGER,
+      G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  props[PROP_LOCKSCREEN_MANAGER] =
+    g_param_spec_object (
+      "lockscreen-manager",
+      "Lockscren manager",
+      "The object managing the lock screen",
+      PHOSH_TYPE_LOCKSCREEN_MANAGER,
+      G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  props[PROP_MONITOR] =
+    g_param_spec_object (
+      "monitor",
+      "Monitor",
+      "The monitor to rotate",
+      PHOSH_TYPE_MONITOR,
+      G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  props[PROP_ORIENTATION_LOCKED] =
+    g_param_spec_boolean (
+      "orientation-locked",
+      "Screen orientation locked",
+      "Whether the screen orientation is locked",
+      TRUE,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  props[PROP_MODE] =
+    g_param_spec_enum (
+      "mode",
+      "Rotation mode",
+      "The current rotation mode",
+      PHOSH_TYPE_ROTATION_MANAGER_MODE,
+      PHOSH_ROTATION_MANAGER_MODE_OFF,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  g_object_class_install_properties (object_class, LAST_PROP, props);
+}
+
+static void
+phosh_rotation_manager_init (PhoshRotationManager *self)
+{
+}
+
+
+PhoshRotationManager *
+phosh_rotation_manager_new (PhoshSensorProxyManager *sensor_proxy_manager,
+                            PhoshLockscreenManager  *lockscreen_manager,
+                            PhoshMonitor *monitor)
+{
+  return g_object_new (PHOSH_TYPE_ROTATION_MANAGER,
+                       "sensor-proxy-manager", sensor_proxy_manager,
+                       "lockscreen-manager", lockscreen_manager,
+                       "monitor", monitor,
+                       NULL);
+}
+
+void
+phosh_rotation_manager_set_orientation_locked (PhoshRotationManager *self, gboolean locked)
+{
+  g_return_if_fail (PHOSH_IS_ROTATION_MANAGER (self));
+
+  if (locked == self->orientation_locked)
+    return;
+
+  self->orientation_locked = locked;
+  g_object_notify_by_pspec (G_OBJECT (self), props[PROP_ORIENTATION_LOCKED]);
+  match_orientation (self);
+}
+
+gboolean
+phosh_rotation_manager_get_orientation_locked (PhoshRotationManager *self)
+{
+  g_return_val_if_fail (PHOSH_IS_ROTATION_MANAGER (self), TRUE);
+
+  return self->orientation_locked;
+}
+
+PhoshRotationManagerMode
+phosh_rotation_manager_get_mode (PhoshRotationManager *self)
+{
+  g_return_val_if_fail (PHOSH_IS_ROTATION_MANAGER (self), PHOSH_ROTATION_MANAGER_MODE_OFF);
+
+  return self->mode;
+}
+
+/**
+ * phosh_rotation_manager_set_mode:
+ * @self: The #PhoshRotationManager
+ * @mode: The #PhoshRotationManagerMode to set
+ *
+ * Sets the given mode.
+ * Returns: %TRUE if setting the mode was possible, otherwise %FALSE (e.g. when trying
+ * to set %PHOSH_ROTATION_MANAGER_MODE_SENSOR without having a sensor.
+ */
+gboolean
+phosh_rotation_manager_set_mode (PhoshRotationManager *self, PhoshRotationManagerMode mode)
+{
+  gboolean has_accel;
+
+  g_return_val_if_fail (PHOSH_IS_ROTATION_MANAGER (self), FALSE);
+
+  if (mode == self->mode)
+    return TRUE;
+
+  has_accel = phosh_dbus_sensor_proxy_get_has_accelerometer (
+    PHOSH_DBUS_SENSOR_PROXY (self->sensor_proxy_manager));
+
+  if (mode == PHOSH_ROTATION_MANAGER_MODE_SENSOR && !has_accel)
+    return FALSE;
+
+  self->mode = mode;
+
+  g_debug ("Setting mode: %d", mode);
+  switch (mode) {
+  case PHOSH_ROTATION_MANAGER_MODE_OFF:
+    phosh_rotation_manager_claim_accelerometer (self, FALSE);
+    break;
+  case PHOSH_ROTATION_MANAGER_MODE_SENSOR:
+    /* Don't claim during screen lock, enables runtime pm and will be
+       claimed on unlock */
+    if (!phosh_lockscreen_manager_get_locked (self->lockscreen_manager))
+      phosh_rotation_manager_claim_accelerometer (self, TRUE);
+    break;
+  default:
+    g_assert_not_reached ();
+  }
+
+  g_object_notify_by_pspec (G_OBJECT (self), props[PROP_MODE]);
+  return TRUE;
+}
+
+
+void
+phosh_rotation_manager_set_transform (PhoshRotationManager   *self,
+                                      PhoshMonitorTransform  transform)
+{
+  g_return_if_fail (PHOSH_IS_ROTATION_MANAGER (self));
+  g_return_if_fail (self->mode == PHOSH_ROTATION_MANAGER_MODE_OFF);
+
+  apply_transform (self, transform);
+}
+
+PhoshMonitorTransform
+phosh_rotation_manager_get_transform (PhoshRotationManager *self)
+{
+  g_return_val_if_fail (PHOSH_IS_ROTATION_MANAGER (self),
+                        PHOSH_MONITOR_TRANSFORM_NORMAL);
+
+  return self->monitor->transform;
+}
+
+/**
+ * phosh_rotation_manager_get_monitor:
+ * @self: The PhoshRotationManager
+ *
+ * Returns: The #PhoshMonitor this manager acts on
+ */
+PhoshMonitor *
+phosh_rotation_manager_get_monitor (PhoshRotationManager *self)
+{
+  g_return_val_if_fail (PHOSH_IS_ROTATION_MANAGER (self), NULL);
+
+  return self->monitor;
+}
diff --git a/src/rotation-manager.h b/src/rotation-manager.h
new file mode 100644
index 00000000..b09926b5
--- /dev/null
+++ b/src/rotation-manager.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2021 Purism SPC
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+#pragma once
+
+#include "lockscreen-manager.h"
+#include "sensor-proxy-manager.h"
+#include "monitor/monitor.h"
+
+G_BEGIN_DECLS
+
+/**
+ * PhoshRotationManagerMode:
+ * @PHOSH_ROTATION_MANAGER_MODE_OFF: automatic rotation off
+ * @PHOSH_ROTATION_MANAGER_MODE_SENSOR: rotation driven by sensor orientation
+ *
+ * The mode of a #PhoshRotationManager
+ */
+typedef enum {
+  PHOSH_ROTATION_MANAGER_MODE_OFF,
+  PHOSH_ROTATION_MANAGER_MODE_SENSOR,
+} PhoshRotationManagerMode;
+
+#define PHOSH_TYPE_ROTATION_MANAGER (phosh_rotation_manager_get_type ())
+
+G_DECLARE_FINAL_TYPE (PhoshRotationManager, phosh_rotation_manager, PHOSH, ROTATION_MANAGER, GObject);
+
+PhoshRotationManager *phosh_rotation_manager_new (PhoshSensorProxyManager *sensor_proxy_manager,
+                                                  PhoshLockscreenManager  *lockscreen_manager,
+                                                  PhoshMonitor            *monitor);
+void                  phosh_rotation_manager_set_orientation_locked (PhoshRotationManager *self,
+                                                                     gboolean              locked);
+gboolean              phosh_rotation_manager_get_orientation_locked (PhoshRotationManager *self);
+
+PhoshRotationManagerMode phosh_rotation_manager_get_mode (PhoshRotationManager *self);
+gboolean                 phosh_rotation_manager_set_mode (PhoshRotationManager *self,
+                                                          PhoshRotationManagerMode mode);
+void                     phosh_rotation_manager_set_transform (PhoshRotationManager  *self,
+                                                               PhoshMonitorTransform  tranform);
+PhoshMonitorTransform    phosh_rotation_manager_get_transform  (PhoshRotationManager *self);
+PhoshMonitor            *phosh_rotation_manager_get_monitor    (PhoshRotationManager *self);
+
+G_END_DECLS
diff --git a/src/shell.c b/src/shell.c
index 6f0d3663..57caff0d 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -59,6 +59,7 @@
 #include "proximity.h"
 #include "quick-setting.h"
 #include "rotateinfo.h"
+#include "rotation-manager.h"
 #include "sensor-proxy-manager.h"
 #include "screen-saver-manager.h"
 #include "session-manager.h"
@@ -129,6 +130,7 @@ typedef struct
   /* sensors */
   PhoshSensorProxyManager *sensor_proxy_manager;
   PhoshProximity *proximity;
+  PhoshRotationManager *rotation_manager;
 
   gboolean startup_finished;
   PhoshMonitorTransform transform; /* current rotation of primary monitor */
@@ -372,7 +374,9 @@ phosh_shell_dispose (GObject *object)
 
   /* sensors */
   g_clear_object (&priv->proximity);
+  g_clear_object (&priv->rotation_manager);
   g_clear_object (&priv->sensor_proxy_manager);
+
   phosh_system_prompter_unregister ();
   g_clear_object (&priv->session_manager);
 
@@ -1094,6 +1098,24 @@ phosh_shell_get_session_manager (PhoshShell *self)
 }
 
 
+PhoshRotationManager *
+phosh_shell_get_rotation_manager (PhoshShell *self)
+{
+  PhoshShellPrivate *priv;
+
+  g_return_val_if_fail (PHOSH_IS_SHELL (self), NULL);
+  priv = phosh_shell_get_instance_private (self);
+
+  if (!priv->rotation_manager)
+    priv->rotation_manager = phosh_rotation_manager_new (priv->sensor_proxy_manager,
+                                                         priv->lockscreen_manager,
+                                                         priv->builtin_monitor);
+
+  g_return_val_if_fail (PHOSH_IS_ROTATION_MANAGER (priv->rotation_manager), NULL);
+
+  return priv->rotation_manager;
+}
+
 /**
  * Returns the usable area in pixels usable by a client on the phone
  * display
diff --git a/src/shell.h b/src/shell.h
index 1b21eef8..d7cfcdbd 100644
--- a/src/shell.h
+++ b/src/shell.h
@@ -17,6 +17,7 @@
 #include "monitor-manager.h"
 #include "monitor/monitor.h"
 #include "osk-manager.h"
+#include "rotation-manager.h"
 #include "session-manager.h"
 #include "toplevel-manager.h"
 #include "torch-manager.h"
@@ -79,6 +80,7 @@ PhoshWifiManager    *phosh_shell_get_wifi_manager    (PhoshShell *self);
 PhoshFeedbackManager *phosh_shell_get_feedback_manager (PhoshShell *self);
 PhoshBtManager      *phosh_shell_get_bt_manager      (PhoshShell *self);
 PhoshWWan           *phosh_shell_get_wwan        (PhoshShell *self);
+PhoshRotationManager *phosh_shell_get_rotation_manager (PhoshShell *self);
 PhoshTorchManager   *phosh_shell_get_torch_manager (PhoshShell *self);
 PhoshDockedManager  *phosh_shell_get_docked_manager (PhoshShell *self);
 PhoshHksManager *    phosh_shell_get_hks_manager     (PhoshShell *self);
-- 
GitLab


From dd6c6124596a4b415dedbf6d92c57afac8c8b90f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Tue, 23 Jun 2020 14:08:53 +0200
Subject: [PATCH 10/23] rotateinfo: Display either rotation lock or orientation
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on the rotation managers mode dislay appropriate information.

Closes: #18

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/rotateinfo.c | 82 +++++++++++++++++++++++++++++++++++-------------
 src/rotateinfo.h | 16 +++++++++-
 2 files changed, 76 insertions(+), 22 deletions(-)

diff --git a/src/rotateinfo.c b/src/rotateinfo.c
index b673fa3d..1227d65d 100644
--- a/src/rotateinfo.c
+++ b/src/rotateinfo.c
@@ -15,28 +15,35 @@
 
 /**
  * SECTION:rotateinfo
- * @short_description: A widget to display the rotate status
+ * @short_description: A widget to display the rotate lock status
  * @Title: PhoshRotateInfo
  *
- * Rotate Info widget
+ * A #PhoshStatusIcon to display the rotation lock status.
+ * It can either display whether a rotation lock is currently active or
+ * if the output is in portrait/landscape mode.
  */
 
 typedef struct _PhoshRotateInfo {
-  PhoshStatusIcon parent;
+  PhoshStatusIcon     parent;
+
+  PhoshRotationManager *manager;
 } PhoshRotateInfo;
 
 
 G_DEFINE_TYPE (PhoshRotateInfo, phosh_rotate_info, PHOSH_TYPE_STATUS_ICON)
 
-
 static void
-set_state (PhoshRotateInfo *self)
+on_transform_changed (PhoshRotateInfo *self)
 {
   PhoshShell *shell = phosh_shell_get_default ();
   PhoshMonitor *monitor = phosh_shell_get_primary_monitor (shell);
   gboolean monitor_is_landscape;
   gboolean portrait;
 
+  if (phosh_rotation_manager_get_mode (self->manager) != PHOSH_ROTATION_MANAGER_MODE_OFF) {
+    return;
+  }
+
   switch (phosh_shell_get_transform (shell)) {
   case PHOSH_MONITOR_TRANSFORM_NORMAL:
   case PHOSH_MONITOR_TRANSFORM_FLIPPED:
@@ -71,37 +78,70 @@ set_state (PhoshRotateInfo *self)
 
 
 static void
-phosh_rotate_info_finalize (GObject *object)
+on_orientation_lock_changed (PhoshRotateInfo *self)
 {
-  PhoshRotateInfo *self = PHOSH_ROTATE_INFO(object);
+  gboolean locked = phosh_rotation_manager_get_orientation_locked (self->manager);
+  const char *icon_name;
 
-  g_signal_handlers_disconnect_by_data (phosh_shell_get_default (), self);
+  if (phosh_rotation_manager_get_mode (self->manager) != PHOSH_ROTATION_MANAGER_MODE_SENSOR)
+    return;
 
-  G_OBJECT_CLASS (phosh_rotate_info_parent_class)->finalize (object);
+  g_debug ("Orientation locked: %d", locked);
+
+  icon_name = locked ? "rotation-locked-symbolic" : "rotation-allowed-symbolic";
+  phosh_status_icon_set_icon_name (PHOSH_STATUS_ICON (self), icon_name);
+  /* Translators: Automatic screen orientation is either on (enabled) or off (locked/disabled) */
+  phosh_status_icon_set_info (PHOSH_STATUS_ICON (self), locked ? _("Off") : _("On"));
+
+  return;
 }
 
 
 static void
-phosh_rotate_info_class_init (PhoshRotateInfoClass *klass)
+on_mode_changed (PhoshRotateInfo *self)
 {
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-  object_class->finalize = phosh_rotate_info_finalize;
+  PhoshRotationManagerMode mode = phosh_rotation_manager_get_mode (self->manager);
+
+  g_debug ("Rotation manager mode: %d", mode);
+  switch (mode) {
+  case PHOSH_ROTATION_MANAGER_MODE_OFF:
+    on_transform_changed (self);
+    break;
+  case PHOSH_ROTATION_MANAGER_MODE_SENSOR:
+    on_orientation_lock_changed (self);
+    break;
+  default:
+    g_assert_not_reached ();
+  }
 }
 
 
 static void
-phosh_rotate_info_init (PhoshRotateInfo *self)
+phosh_rotate_info_class_init (PhoshRotateInfoClass *klass)
 {
-  g_signal_connect_swapped (phosh_shell_get_default (),
-                            "notify::transform",
-                            G_CALLBACK (set_state),
-                            self);
-  set_state (self);
 }
 
 
-GtkWidget *
-phosh_rotate_info_new (void)
+static void
+phosh_rotate_info_init (PhoshRotateInfo *self)
 {
-  return g_object_new (PHOSH_TYPE_ROTATE_INFO, NULL);
+  self->manager = phosh_shell_get_rotation_manager (phosh_shell_get_default());
+
+  /* We don't use property bindings since we flip info/icon based on rotation and lock */
+  g_signal_connect_object (phosh_shell_get_default (),
+                           "notify::transform",
+                           G_CALLBACK (on_transform_changed),
+                           self,
+                           G_CONNECT_SWAPPED);
+  g_signal_connect_object (self->manager,
+                           "notify::orientation-locked",
+                           G_CALLBACK (on_orientation_lock_changed),
+                           self,
+                           G_CONNECT_SWAPPED);
+  g_signal_connect_object (self->manager,
+                           "notify::mode",
+                           G_CALLBACK (on_mode_changed),
+                           self,
+                           G_CONNECT_SWAPPED);
+  on_mode_changed (self);
 }
diff --git a/src/rotateinfo.h b/src/rotateinfo.h
index 2e05f818..1195fed6 100644
--- a/src/rotateinfo.h
+++ b/src/rotateinfo.h
@@ -11,10 +11,24 @@
 
 G_BEGIN_DECLS
 
+/**
+ * PhoshRotateInfoMode:
+ * @PHOSH_ROTATE_INFO_MODE_LOCK: Button toggles rotation lock
+ * @PHOSH_ROTATE_INFO_MODE_TOGGLE: Button toggles potrait/landscape
+ *
+ * The power save mode of a monitor
+ */
+typedef enum {
+  PHOSH_ROTATE_INFO_MODE_LOCK,
+  PHOSH_ROTATE_INFO_MODE_TOGGLE,
+} PhoshRotateInfoMode;
+
 #define PHOSH_TYPE_ROTATE_INFO (phosh_rotate_info_get_type())
 
 G_DECLARE_FINAL_TYPE (PhoshRotateInfo, phosh_rotate_info, PHOSH, ROTATE_INFO, PhoshStatusIcon)
 
-GtkWidget * phosh_rotate_info_new (void);
+GtkWidget           *phosh_rotate_info_new (void);
+PhoshRotateInfoMode  phosh_rotate_info_get_mode (PhoshRotateInfo *self);
+void                 phosh_rotate_info_set_mode (PhoshRotateInfo *self, PhoshRotateInfoMode mode);
 
 G_END_DECLS
-- 
GitLab


From 134dcc15393cb972fc121c739c6a708ed037c182 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Tue, 23 Jun 2020 14:10:38 +0200
Subject: [PATCH 11/23] settings: Add orientation lock to rotate quick setting
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Long press switches between potrait/landscape and rotation lock.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/settings.c          | 53 +++++++++++++++++++++++++++++++++++++----
 src/ui/settings-menu.ui |  1 +
 2 files changed, 50 insertions(+), 4 deletions(-)

diff --git a/src/settings.c b/src/settings.c
index eb55486e..54a60d9a 100644
--- a/src/settings.c
+++ b/src/settings.c
@@ -20,6 +20,7 @@
 #include "feedback-manager.h"
 #include "notifications/notify-manager.h"
 #include "notifications/notification-frame.h"
+#include "rotateinfo.h"
 
 #include <pulse/pulseaudio.h>
 #include "gvc-mixer-control.h"
@@ -82,16 +83,59 @@ static void
 rotation_setting_clicked_cb (PhoshSettings *self)
 {
   PhoshShell *shell = phosh_shell_get_default ();
+  PhoshRotationManager *rotation_manager;
+  PhoshRotationManagerMode mode;
   PhoshMonitorTransform transform;
+  gboolean locked;
 
   g_return_if_fail (PHOSH_IS_SETTINGS (self));
-  transform = phosh_shell_get_transform (shell);
-  phosh_shell_set_transform (shell, transform == PHOSH_MONITOR_TRANSFORM_NORMAL
-                             ? PHOSH_MONITOR_TRANSFORM_270
-                             : PHOSH_MONITOR_TRANSFORM_NORMAL);
+
+  rotation_manager = phosh_shell_get_rotation_manager (shell);
+  g_return_if_fail (rotation_manager);
+  mode = phosh_rotation_manager_get_mode (PHOSH_ROTATION_MANAGER (rotation_manager));
+
+  switch (mode) {
+  case PHOSH_ROTATION_MANAGER_MODE_OFF:
+    transform = phosh_rotation_manager_get_transform (rotation_manager) ?
+      PHOSH_MONITOR_TRANSFORM_NORMAL : PHOSH_MONITOR_TRANSFORM_270;
+    phosh_rotation_manager_set_transform (rotation_manager, transform);
+    break;
+  case PHOSH_ROTATION_MANAGER_MODE_SENSOR:
+    locked = phosh_rotation_manager_get_orientation_locked (rotation_manager);
+    phosh_rotation_manager_set_orientation_locked (rotation_manager, !locked);
+    break;
+  default:
+    g_assert_not_reached ();
+  }
+
   g_signal_emit (self, signals[SETTING_DONE], 0);
 }
 
+static void
+rotation_setting_long_pressed_cb (PhoshSettings *self)
+{
+  PhoshShell *shell = phosh_shell_get_default ();
+  PhoshRotateInfoMode mode;
+  PhoshRotationManager *rotation_manager;
+
+  rotation_manager = phosh_shell_get_rotation_manager (shell);
+  g_return_if_fail (rotation_manager);
+
+  mode = phosh_rotation_manager_get_mode (rotation_manager);
+  switch (mode) {
+  case PHOSH_ROTATION_MANAGER_MODE_OFF:
+    mode = PHOSH_ROTATION_MANAGER_MODE_SENSOR;
+    break;
+  case PHOSH_ROTATION_MANAGER_MODE_SENSOR:
+    mode = PHOSH_ROTATION_MANAGER_MODE_OFF;
+    break;
+  default:
+    g_assert_not_reached ();
+  }
+  g_debug ("Rotation manager mode: %d", mode);
+  phosh_rotation_manager_set_mode (rotation_manager, mode);
+}
+
 static void
 feedback_setting_clicked_cb (PhoshSettings *self)
 {
@@ -481,6 +525,7 @@ phosh_settings_class_init (PhoshSettingsClass *klass)
   gtk_widget_class_bind_template_callback (widget_class, feedback_setting_long_pressed_cb);
   gtk_widget_class_bind_template_callback (widget_class, on_media_player_raised);
   gtk_widget_class_bind_template_callback (widget_class, rotation_setting_clicked_cb);
+  gtk_widget_class_bind_template_callback (widget_class, rotation_setting_long_pressed_cb);
   gtk_widget_class_bind_template_callback (widget_class, torch_setting_clicked_cb);
   gtk_widget_class_bind_template_callback (widget_class, wifi_setting_clicked_cb);
   gtk_widget_class_bind_template_callback (widget_class, wwan_setting_clicked_cb);
diff --git a/src/ui/settings-menu.ui b/src/ui/settings-menu.ui
index da196806..af7ee9ce 100644
--- a/src/ui/settings-menu.ui
+++ b/src/ui/settings-menu.ui
@@ -95,6 +95,7 @@
                     <property name="visible">True</property>
                     <property name="can_focus">False</property>
                     <signal name="clicked" handler="rotation_setting_clicked_cb" object="PhoshSettings" swapped="yes"/>
+                    <signal name="long-pressed" handler="rotation_setting_long_pressed_cb" object="PhoshSettings" swapped="yes"/>
                     <child>
                       <object class="PhoshRotateInfo" id="rotateinfo">
                         <property name="visible">True</property>
-- 
GitLab


From 2ec5679c5ca3ddb5651ed1a6fc3763f405066a00 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Sun, 28 Mar 2021 19:27:06 +0200
Subject: [PATCH 12/23] settings: Don't close menu when toggling rotation lock
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This makes it consistent with other toggles like feedback toggle.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/settings.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/src/settings.c b/src/settings.c
index 54a60d9a..81a095c9 100644
--- a/src/settings.c
+++ b/src/settings.c
@@ -99,6 +99,7 @@ rotation_setting_clicked_cb (PhoshSettings *self)
     transform = phosh_rotation_manager_get_transform (rotation_manager) ?
       PHOSH_MONITOR_TRANSFORM_NORMAL : PHOSH_MONITOR_TRANSFORM_270;
     phosh_rotation_manager_set_transform (rotation_manager, transform);
+    g_signal_emit (self, signals[SETTING_DONE], 0);
     break;
   case PHOSH_ROTATION_MANAGER_MODE_SENSOR:
     locked = phosh_rotation_manager_get_orientation_locked (rotation_manager);
@@ -107,8 +108,6 @@ rotation_setting_clicked_cb (PhoshSettings *self)
   default:
     g_assert_not_reached ();
   }
-
-  g_signal_emit (self, signals[SETTING_DONE], 0);
 }
 
 static void
-- 
GitLab


From 7187a857322059e7ac8e05b83fb6adb259111479 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Fri, 26 Mar 2021 10:00:37 +0100
Subject: [PATCH 13/23] Move Lockscreen rotation fixup to rotation-manager
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

No need to have several objects involved. This avoids
lockscreen and rotation manager racing since we can
do it past the unclaim of the accelerometer.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/lockscreen-manager.c | 38 -------------------
 src/rotation-manager.c   | 82 +++++++++++++++++++++++++++++++++++++++-
 2 files changed, 80 insertions(+), 40 deletions(-)

diff --git a/src/lockscreen-manager.c b/src/lockscreen-manager.c
index 54041c5c..0c8c16b0 100644
--- a/src/lockscreen-manager.c
+++ b/src/lockscreen-manager.c
@@ -77,10 +77,6 @@ lockscreen_unlock_cb (PhoshLockscreenManager *self, PhoshLockscreen *lockscreen)
   g_return_if_fail (PHOSH_IS_LOCKSCREEN (lockscreen));
   g_return_if_fail (lockscreen == PHOSH_LOCKSCREEN (self->lockscreen));
 
-  /* Fixup transform in case the lockscreen needed to rotate to unlock */
-  g_debug ("Restoring transform %d", self->transform);
-  phosh_shell_set_transform (shell, self->transform);
-
   g_signal_handlers_disconnect_by_data (monitor_manager, self);
   g_signal_handlers_disconnect_by_data (primary_monitor, self);
   g_signal_handlers_disconnect_by_data (shell, self);
@@ -171,35 +167,6 @@ on_monitor_added (PhoshLockscreenManager *self,
   lock_monitor (self, monitor);
 }
 
-static void
-on_primary_monitor_power_mode_changed (PhoshLockscreenManager *self,
-                                       GParamSpec             *pspec,
-                                       PhoshMonitor           *monitor)
-{
-  PhoshShell *shell = phosh_shell_get_default ();
-  PhoshModeManager *mode_manager = phosh_shell_get_mode_manager(shell);
-
-  /*
-   * Only phones need to switch orientation so that the lock screen fits
-   * https://source.puri.sm/Librem5/phosh/-/issues/388
-   */
-  if (phosh_mode_manager_get_device_type(mode_manager) != PHOSH_MODE_DEVICE_TYPE_PHONE)
-    return;
-
-  /* Don't mess with transforms on external screens either */
-  if (!phosh_monitor_is_builtin (monitor))
-    return;
-
-  switch (phosh_monitor_get_power_save_mode (monitor)) {
-  case PHOSH_MONITOR_POWER_SAVE_MODE_ON:
-    phosh_shell_set_transform (shell, PHOSH_MONITOR_TRANSFORM_NORMAL);
-    break;
-  case PHOSH_MONITOR_POWER_SAVE_MODE_OFF:
-    break;
-  default:
-    g_warn_if_reached ();
-  }
-}
 
 static void
 lock_primary_monitor (PhoshLockscreenManager *self)
@@ -209,7 +176,6 @@ lock_primary_monitor (PhoshLockscreenManager *self)
   PhoshShell *shell = phosh_shell_get_default ();
 
   primary_monitor = phosh_shell_get_primary_monitor (shell);
-  self->transform = phosh_shell_get_transform (shell);
 
   /* The primary output gets the clock, keypad, ... */
   self->lockscreen = PHOSH_LOCKSCREEN (phosh_lockscreen_new (
@@ -222,10 +188,6 @@ lock_primary_monitor (PhoshLockscreenManager *self)
     "swapped-object-signal::wakeup-output", G_CALLBACK (lockscreen_wakeup_output_cb), self,
     NULL);
 
-  g_signal_connect_swapped (primary_monitor, "notify::power-mode",
-                            G_CALLBACK(on_primary_monitor_power_mode_changed),
-                            self);
-
   gtk_widget_show (GTK_WIDGET (self->lockscreen));
   /* Old lockscreen gets remove due to `layer_surface_closed` */
 }
diff --git a/src/rotation-manager.c b/src/rotation-manager.c
index ba847553..b22b58de 100644
--- a/src/rotation-manager.c
+++ b/src/rotation-manager.c
@@ -47,6 +47,7 @@ typedef struct _PhoshRotationManager {
   PhoshSensorProxyManager *sensor_proxy_manager;
   PhoshLockscreenManager  *lockscreen_manager;
   PhoshMonitor            *monitor;
+  PhoshMonitorTransform    prelock_transform;
 
   GSettings               *settings;
   gboolean                 orientation_locked;
@@ -210,6 +211,67 @@ on_has_accelerometer_changed (PhoshRotationManager    *self,
   phosh_rotation_manager_set_mode (self, mode);
 }
 
+/**
+ * fixup_lockscreen_orientation:
+ * @self: The PhoshRotationManager
+ * @force: Whether to force the monitor to normal orientation
+ *
+ * On phones the lock screen doesn't work in landscape so fix that
+ * until https://source.puri.sm/Librem5/phosh/-/issues/388
+ * is fixed. Keep all of this local to this function.
+ */
+static void
+fixup_lockscreen_orientation (PhoshRotationManager *self, gboolean force)
+{
+  PhoshShell *shell = phosh_shell_get_default ();
+  PhoshModeManager *mode_manager = phosh_shell_get_mode_manager(shell);
+
+  g_return_if_fail (PHOSH_IS_MODE_MANAGER (mode_manager));
+  g_return_if_fail (PHOSH_IS_MONITOR (self->monitor));
+
+  /* Only bother on phones */
+  if (phosh_mode_manager_get_device_type(mode_manager) != PHOSH_MODE_DEVICE_TYPE_PHONE &&
+      phosh_mode_manager_get_device_type(mode_manager) != PHOSH_MODE_DEVICE_TYPE_UNKNOWN)
+    return;
+
+  /* Don't mess with transforms on external screens either */
+  if (!phosh_monitor_is_builtin (self->monitor))
+    return;
+
+  if (phosh_lockscreen_manager_get_locked (self->lockscreen_manager)) {
+    if (force) {
+      g_debug ("Forcing normal transform");
+      apply_transform (self, PHOSH_MONITOR_TRANSFORM_NORMAL);
+    } else {
+      self->prelock_transform = phosh_monitor_get_transform (self->monitor);
+      g_debug ("Saving transform %d", self->prelock_transform);
+    }
+  } else {
+    g_debug ("Restoring transform %d", self->prelock_transform);
+    apply_transform (self, self->prelock_transform);
+  }
+}
+
+
+static void
+on_power_mode_changed (PhoshRotationManager *self,
+                       GParamSpec *pspec,
+                       PhoshMonitor *monitor)
+{
+  PhoshMonitorPowerSaveMode mode;
+
+  g_return_if_fail (PHOSH_IS_ROTATION_MANAGER (self));
+  g_return_if_fail (PHOSH_IS_MONITOR (monitor));
+
+  mode = phosh_monitor_get_power_save_mode (monitor);
+  g_debug ("Mode: %d", mode);
+  if (mode != PHOSH_MONITOR_POWER_SAVE_MODE_ON)
+    return;
+
+  fixup_lockscreen_orientation (self, TRUE);
+}
+
+
 static void
 on_lockscreen_manager_locked (PhoshRotationManager *self, GParamSpec *pspec,
                               PhoshLockscreenManager *lockscreen_manager)
@@ -225,6 +287,8 @@ on_lockscreen_manager_locked (PhoshRotationManager *self, GParamSpec *pspec,
     claim = !phosh_lockscreen_manager_get_locked (self->lockscreen_manager);
 
   phosh_rotation_manager_claim_accelerometer (self, claim);
+
+  fixup_lockscreen_orientation (self, FALSE);
 }
 
 static void
@@ -321,8 +385,17 @@ phosh_rotation_manager_constructed (GObject *object)
                             self);
   on_lockscreen_manager_locked (self, NULL, self->lockscreen_manager);
 
-  if (!self->sensor_proxy_manager)
+  g_signal_connect_swapped (self->monitor,
+                            "notify::power-mode",
+                            (GCallback) on_power_mode_changed,
+                            self);
+  on_power_mode_changed (self, NULL, self->monitor);
+
+
+  if (!self->sensor_proxy_manager) {
+    g_warning ("Got not sensor-proxy, no automatic rotation");
     return;
+  }
 
   g_signal_connect_swapped (self->sensor_proxy_manager,
                             "notify::accelerometer-orientation",
@@ -358,7 +431,12 @@ phosh_rotation_manager_dispose (GObject *object)
                                           self);
     g_clear_object (&self->lockscreen_manager);
   }
-  g_clear_object (&self->monitor);
+
+  if (self->monitor) {
+    g_signal_handlers_disconnect_by_data (self->monitor,
+                                          self);
+    g_clear_object (&self->monitor);
+  }
 
   G_OBJECT_CLASS (phosh_rotation_manager_parent_class)->dispose (object);
 }
-- 
GitLab


From 2355bc52dd6a35403a9e7597499c3fd1662e9e87 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Fri, 26 Mar 2021 10:31:31 +0100
Subject: [PATCH 14/23] rotateinfo: Use monitor from rotation-manager
 consistently
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

So far this was dependent on mode and incorrectly tracked the primary
monitor for manual toggle.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/rotateinfo.c       |  8 ++++----
 src/rotation-manager.c | 38 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 42 insertions(+), 4 deletions(-)

diff --git a/src/rotateinfo.c b/src/rotateinfo.c
index 1227d65d..149b5d4d 100644
--- a/src/rotateinfo.c
+++ b/src/rotateinfo.c
@@ -35,8 +35,7 @@ G_DEFINE_TYPE (PhoshRotateInfo, phosh_rotate_info, PHOSH_TYPE_STATUS_ICON)
 static void
 on_transform_changed (PhoshRotateInfo *self)
 {
-  PhoshShell *shell = phosh_shell_get_default ();
-  PhoshMonitor *monitor = phosh_shell_get_primary_monitor (shell);
+  PhoshMonitor *monitor;
   gboolean monitor_is_landscape;
   gboolean portrait;
 
@@ -44,7 +43,7 @@ on_transform_changed (PhoshRotateInfo *self)
     return;
   }
 
-  switch (phosh_shell_get_transform (shell)) {
+  switch (phosh_rotation_manager_get_transform (self->manager)) {
   case PHOSH_MONITOR_TRANSFORM_NORMAL:
   case PHOSH_MONITOR_TRANSFORM_FLIPPED:
   case PHOSH_MONITOR_TRANSFORM_180:
@@ -63,6 +62,7 @@ on_transform_changed (PhoshRotateInfo *self)
   }
 
   /* If we have a landscape monitor (tv, laptop) flip the rotation */
+  monitor = phosh_rotation_manager_get_monitor (self->manager);
   monitor_is_landscape = ((double)monitor->width / (double)monitor->height) > 1.0;
   portrait = monitor_is_landscape ? !portrait : portrait;
 
@@ -128,7 +128,7 @@ phosh_rotate_info_init (PhoshRotateInfo *self)
   self->manager = phosh_shell_get_rotation_manager (phosh_shell_get_default());
 
   /* We don't use property bindings since we flip info/icon based on rotation and lock */
-  g_signal_connect_object (phosh_shell_get_default (),
+  g_signal_connect_object (self->manager,
                            "notify::transform",
                            G_CALLBACK (on_transform_changed),
                            self,
diff --git a/src/rotation-manager.c b/src/rotation-manager.c
index b22b58de..1a4263d9 100644
--- a/src/rotation-manager.c
+++ b/src/rotation-manager.c
@@ -36,6 +36,7 @@ enum {
   PROP_ORIENTATION_LOCKED,
   PROP_MONITOR,
   PROP_MODE,
+  PROP_TRANSFORM,
   LAST_PROP,
 };
 static GParamSpec *props[LAST_PROP];
@@ -47,6 +48,7 @@ typedef struct _PhoshRotationManager {
   PhoshSensorProxyManager *sensor_proxy_manager;
   PhoshLockscreenManager  *lockscreen_manager;
   PhoshMonitor            *monitor;
+  PhoshMonitorTransform    transform;
   PhoshMonitorTransform    prelock_transform;
 
   GSettings               *settings;
@@ -302,6 +304,26 @@ on_accelerometer_orientation_changed (PhoshRotationManager    *self,
   match_orientation (self);
 }
 
+
+static void
+on_monitor_configured (PhoshRotationManager   *self,
+                       PhoshMonitor           *monitor)
+{
+  PhoshMonitorTransform transform;
+
+  g_return_if_fail (PHOSH_IS_ROTATION_MANAGER (self));
+  g_return_if_fail (PHOSH_IS_MONITOR (monitor));
+
+  transform = phosh_monitor_get_transform (monitor);
+  if (transform == self->transform)
+    return;
+
+  self->transform = transform;
+  g_debug ("Rotation-manager transform %d", transform);
+  g_object_notify_by_pspec (G_OBJECT (self), props[PROP_TRANSFORM]);
+}
+
+
 static void
 phosh_rotation_manager_set_property (GObject      *object,
                                      guint         property_id,
@@ -357,6 +379,9 @@ phosh_rotation_manager_get_property (GObject    *object,
   case PROP_MODE:
     g_value_set_enum (value, self->mode);
     break;
+  case PROP_TRANSFORM:
+    g_value_set_enum (value, self->transform);
+    break;
   default:
     G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
     break;
@@ -391,6 +416,11 @@ phosh_rotation_manager_constructed (GObject *object)
                             self);
   on_power_mode_changed (self, NULL, self->monitor);
 
+  g_signal_connect_swapped (self->monitor,
+                            "configured",
+                            G_CALLBACK (on_monitor_configured),
+                            self);
+  on_monitor_configured (self, self->monitor);
 
   if (!self->sensor_proxy_manager) {
     g_warning ("Got not sensor-proxy, no automatic rotation");
@@ -493,6 +523,14 @@ phosh_rotation_manager_class_init (PhoshRotationManagerClass *klass)
       PHOSH_ROTATION_MANAGER_MODE_OFF,
       G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
+  props[PROP_TRANSFORM] =
+    g_param_spec_enum ("transform",
+                       "Transform",
+                       "Monitor transform of the rotation monitor",
+                       PHOSH_TYPE_MONITOR_TRANSFORM,
+                       PHOSH_MONITOR_TRANSFORM_NORMAL,
+                       G_PARAM_READABLE | G_PARAM_EXPLICIT_NOTIFY | G_PARAM_STATIC_STRINGS);
+
   g_object_class_install_properties (object_class, LAST_PROP, props);
 }
 
-- 
GitLab


From aaeac724b12108c1df6e9cfd02ca5c52f0805392 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Fri, 26 Mar 2021 10:45:19 +0100
Subject: [PATCH 15/23] shell: Drop transform handling
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This is done by the rotation-manager which always acts on the
given monitor.

Closes: #56

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/shell.c | 86 -----------------------------------------------------
 src/shell.h |  2 --
 2 files changed, 88 deletions(-)

diff --git a/src/shell.c b/src/shell.c
index 57caff0d..30f9a8d9 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -86,7 +86,6 @@
 
 enum {
   PHOSH_SHELL_PROP_0,
-  PHOSH_SHELL_PROP_TRANSFORM,
   PHOSH_SHELL_PROP_LOCKED,
   PHOSH_SHELL_PROP_PRIMARY_MONITOR,
   PHOSH_SHELL_PROP_SHELL_STATE,
@@ -133,7 +132,6 @@ typedef struct
   PhoshRotationManager *rotation_manager;
 
   gboolean startup_finished;
-  PhoshMonitorTransform transform; /* current rotation of primary monitor */
 
   /* Mirrors PhoshLockscreenManager's locked property */
   gboolean locked;
@@ -317,9 +315,6 @@ phosh_shell_get_property (GObject *object,
   PhoshShellPrivate *priv = phosh_shell_get_instance_private(self);
 
   switch (property_id) {
-  case PHOSH_SHELL_PROP_TRANSFORM:
-    g_value_set_enum (value, phosh_monitor_get_transform(priv->primary_monitor));
-    break;
   case PHOSH_SHELL_PROP_LOCKED:
     g_value_set_boolean (value, priv->locked);
     break;
@@ -512,10 +507,6 @@ setup_idle_cb (PhoshShell *self)
                                   g_getenv ("DESKTOP_AUTOSTART_ID"));
   g_unsetenv ("DESKTOP_AUTOSTART_ID");
 
-  /* If we start rotated, fix this up */
-  if (phosh_shell_get_transform (self) != PHOSH_MONITOR_TRANSFORM_NORMAL)
-    phosh_shell_set_transform (self, PHOSH_MONITOR_TRANSFORM_NORMAL);
-
   priv->gnome_shell_manager = phosh_gnome_shell_manager_get_default ();
 
   priv->startup_finished = TRUE;
@@ -563,27 +554,6 @@ on_builtin_monitor_power_mode_changed (PhoshShell *self, GParamSpec *pspec, Phos
 }
 
 
-static void
-on_primary_monitor_configured (PhoshShell   *self,
-                               PhoshMonitor *monitor)
-{
-  PhoshShellPrivate *priv;
-  PhoshMonitorTransform transform;
-
-  g_return_if_fail (PHOSH_IS_SHELL (self));
-  g_return_if_fail (PHOSH_IS_MONITOR (monitor));
-
-  priv = phosh_shell_get_instance_private (self);
-  transform = phosh_monitor_get_transform (monitor);
-  if (transform == priv->transform)
-    return;
-
-  priv->transform = transform;
-  g_debug ("Primary monitor transform %d", transform);
-  g_object_notify_by_pspec (G_OBJECT (self), props[PHOSH_SHELL_PROP_TRANSFORM]);
-}
-
-
 static void
 on_monitor_removed (PhoshShell *self, PhoshMonitor *monitor)
 {
@@ -655,7 +625,6 @@ phosh_shell_constructed (GObject *object)
      exising toplevels */
   priv->toplevel_manager = phosh_toplevel_manager_new ();
 
-  priv->transform = -1; /* force initial update */
   priv->monitor_manager = phosh_monitor_manager_new ();
   g_signal_connect_swapped (priv->monitor_manager,
                             "monitor-removed",
@@ -674,10 +643,6 @@ phosh_shell_constructed (GObject *object)
        object does not really exist yet but we need the primary monitor
        early for the panels */
     priv->primary_monitor = g_object_ref (priv->builtin_monitor);
-    g_signal_connect_swapped (priv->primary_monitor,
-                              "configured",
-                              G_CALLBACK (on_primary_monitor_configured),
-                              self);
   }
 
   gtk_icon_theme_add_resource_path (gtk_icon_theme_get_default (),
@@ -725,14 +690,6 @@ phosh_shell_class_init (PhoshShellClass *klass)
 
   type_setup ();
 
-  props[PHOSH_SHELL_PROP_TRANSFORM] =
-    g_param_spec_enum ("transform",
-                       "Transform",
-                       "Monitor transform of the primary monitor",
-                       PHOSH_TYPE_MONITOR_TRANSFORM,
-                       PHOSH_MONITOR_TRANSFORM_NORMAL,
-                       G_PARAM_READABLE | G_PARAM_EXPLICIT_NOTIFY | G_PARAM_STATIC_STRINGS);
-
   props[PHOSH_SHELL_PROP_LOCKED] =
     g_param_spec_boolean ("locked",
                           "Locked",
@@ -772,44 +729,11 @@ phosh_shell_init (PhoshShell *self)
 }
 
 
-PhoshMonitorTransform
-phosh_shell_get_transform (PhoshShell *self)
-{
-  PhoshShellPrivate *priv;
-
-  g_return_val_if_fail (PHOSH_IS_SHELL (self), PHOSH_MONITOR_TRANSFORM_NORMAL);
-  priv = phosh_shell_get_instance_private (self);
-  g_return_val_if_fail (priv->primary_monitor, PHOSH_MONITOR_TRANSFORM_NORMAL);
-  return phosh_monitor_get_transform (priv->primary_monitor);
-}
-
-
-void
-phosh_shell_set_transform (PhoshShell *self,
-                           PhoshMonitorTransform transform)
-{
-  PhoshShellPrivate *priv = phosh_shell_get_instance_private (self);
-  PhoshMonitorTransform current;
-
-  g_return_if_fail (priv->primary_monitor);
-  current = phosh_monitor_get_transform (priv->primary_monitor);
-  if (current == transform)
-    return;
-
-  phosh_monitor_manager_set_monitor_transform (priv->monitor_manager,
-                                               priv->primary_monitor,
-                                               transform);
-  phosh_monitor_manager_apply_monitor_config (priv->monitor_manager);
-  /* Notification change signalled in on_primary_monitor_configured */
-}
-
-
 void
 phosh_shell_set_primary_monitor (PhoshShell *self, PhoshMonitor *monitor)
 {
   PhoshShellPrivate *priv;
   PhoshMonitor *m = NULL;
-  PhoshMonitorTransform transform;
 
   g_return_if_fail (monitor);
   g_return_if_fail (PHOSH_IS_SHELL (self));
@@ -825,19 +749,9 @@ phosh_shell_set_primary_monitor (PhoshShell *self, PhoshMonitor *monitor)
   }
   g_return_if_fail (monitor == m);
 
-  if (priv->primary_monitor)
-    g_signal_handlers_disconnect_by_data (priv->primary_monitor, self);
   g_clear_object (&priv->primary_monitor);
   priv->primary_monitor = g_object_ref (monitor);
   g_debug ("New primary monitor is %s", monitor->name);
-  g_signal_connect_swapped (priv->primary_monitor,
-                            "configured",
-                            G_CALLBACK (on_primary_monitor_configured),
-                            self);
-  /* Catch up if old and new primary monitor's rotation are different */
-  transform = phosh_monitor_get_transform (priv->primary_monitor);
-  if (transform != priv->transform)
-    on_primary_monitor_configured (self, priv->primary_monitor);
 
   /* Move panels to the new monitor by recreating the layer shell surfaces */
   panels_dispose (self);
diff --git a/src/shell.h b/src/shell.h
index d7cfcdbd..d7aee9d5 100644
--- a/src/shell.h
+++ b/src/shell.h
@@ -57,8 +57,6 @@ G_BEGIN_DECLS
 G_DECLARE_FINAL_TYPE (PhoshShell, phosh_shell, PHOSH, SHELL, GObject)
 
 PhoshShell          *phosh_shell_get_default     (void);
-void                 phosh_shell_set_transform   (PhoshShell *self, PhoshMonitorTransform transform);
-PhoshMonitorTransform phosh_shell_get_transform   (PhoshShell *self);
 void                 phosh_shell_get_usable_area (PhoshShell *self,
                                                   int        *x,
                                                   int        *y,
-- 
GitLab


From 688b171864d20ae8bfb59cac73fa6e9dd0b7c79a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Fri, 26 Mar 2021 15:01:24 +0100
Subject: [PATCH 16/23] rotation-manager: Mess with transform as little as
 possible
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

On phones when we're already using portrait orientation don't bother
fixing this up. This allows for e.g. upside down operation.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/rotation-manager.c | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/src/rotation-manager.c b/src/rotation-manager.c
index 1a4263d9..c5d8d541 100644
--- a/src/rotation-manager.c
+++ b/src/rotation-manager.c
@@ -216,9 +216,9 @@ on_has_accelerometer_changed (PhoshRotationManager    *self,
 /**
  * fixup_lockscreen_orientation:
  * @self: The PhoshRotationManager
- * @force: Whether to force the monitor to normal orientation
+ * @force: Whether to force the monitor to portait orientation
  *
- * On phones the lock screen doesn't work in landscape so fix that
+ * On phones the lock screen doesn't work in landscape so fix that up
  * until https://source.puri.sm/Librem5/phosh/-/issues/388
  * is fixed. Keep all of this local to this function.
  */
@@ -242,8 +242,12 @@ fixup_lockscreen_orientation (PhoshRotationManager *self, gboolean force)
 
   if (phosh_lockscreen_manager_get_locked (self->lockscreen_manager)) {
     if (force) {
-      g_debug ("Forcing normal transform");
-      apply_transform (self, PHOSH_MONITOR_TRANSFORM_NORMAL);
+      PhoshMonitorTransform transform;
+      /* Use prelock transform if portrait, else use normal */
+      transform = (self->prelock_transform % 2) == 0 ? self->prelock_transform :
+        PHOSH_MONITOR_TRANSFORM_NORMAL;
+      g_debug ("Forcing portrait transform: %d", transform);
+      apply_transform (self, transform);
     } else {
       self->prelock_transform = phosh_monitor_get_transform (self->monitor);
       g_debug ("Saving transform %d", self->prelock_transform);
-- 
GitLab


From 85d436f6c1095f125001a04e575e00470454836b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Mon, 29 Mar 2021 17:18:16 +0200
Subject: [PATCH 17/23] monitor: Update org.gnome.Mutter.DisplayConfig
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This is from mutter's 331b5f356311f1dcfc1b580e349a60d25fc0e34f

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/monitor/org.gnome.Mutter.DisplayConfig.xml | 16 +++++++++++-----
 1 file changed, 11 insertions(+), 5 deletions(-)

diff --git a/src/monitor/org.gnome.Mutter.DisplayConfig.xml b/src/monitor/org.gnome.Mutter.DisplayConfig.xml
index fe8e0229..044244e4 100644
--- a/src/monitor/org.gnome.Mutter.DisplayConfig.xml
+++ b/src/monitor/org.gnome.Mutter.DisplayConfig.xml
@@ -101,7 +101,7 @@
 			                     or not
 			    - "presentation" (b): whether this output is
 			                          for presentation only
-			    Note: properties might be ignored if not consistenly
+			    Note: properties might be ignored if not consistently
 			    applied to all outputs in the same clone group. In
 			    general, it's expected that presentation or primary
 			    outputs will not be cloned.
@@ -282,6 +282,14 @@
     -->
     <property name="PowerSaveMode" type="i" access="readwrite" />
 
+    <!--
+        PanelOrientationManaged:
+
+        Whether the built-in panel orientation is automatically managed
+        by mutter.
+    -->
+    <property name="PanelOrientationManaged" type="b" access="read" />
+
     <!--
         MonitorsChanged:
 
@@ -360,13 +368,13 @@
 
 
 	@layout_mode current layout mode represents the way logical monitors
-	are layed out on the screen. Possible modes include:
+	are laid out on the screen. Possible modes include:
 
 	  1 : physical
 	  2 : logical
 
 	With physical layout mode, each logical monitor has the same dimensions
-	an the monitor modes of the associated monitors assigned to it, no
+	as the monitor modes of the associated monitors assigned to it, no
 	matter what scale is in use.
 
 	With logical mode, the dimension of a logical monitor is the dimension
@@ -375,8 +383,6 @@
 
 	Possible @properties are:
 
-	* "supports-mirroring" (b): FALSE if mirroring not supported; TRUE or not
-	                            present if mirroring is supported.
 	* "layout-mode" (u): Represents in what way logical monitors are laid
 			     out on the screen. The layout mode can be either
 			     of the ones listed below. Absence of this property
-- 
GitLab


From 59e6b05136f3ee94acc2a3e18b8e09faf47364fc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Tue, 30 Mar 2021 10:05:18 +0200
Subject: [PATCH 18/23] monitor-manager: Drop supports-mirroring prop
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

It got removed with the DisplayConfig interface update. Mutter doesn't
use it anymore, g-c-c still parses it but doesn't use it in 3.38.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/monitor-manager.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/src/monitor-manager.c b/src/monitor-manager.c
index 6e48ce26..d42f8c40 100644
--- a/src/monitor-manager.c
+++ b/src/monitor-manager.c
@@ -657,9 +657,6 @@ phosh_monitor_manager_handle_get_current_state (
   }
 
   g_variant_builder_init (&properties_builder, G_VARIANT_TYPE ("a{sv}"));
-  g_variant_builder_add (&properties_builder, "{sv}",
-                         "supports-mirroring",
-                         g_variant_new_boolean (FALSE));
 
   g_variant_builder_add (&properties_builder, "{sv}",
                          "layout-mode",
-- 
GitLab


From f2cf35790778bc22cf8fe21eff76cbff71d0d625 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Mon, 29 Mar 2021 18:22:33 +0200
Subject: [PATCH 19/23] monitor-manager: Handle panel-orientation-managed
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Closes: #540

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/monitor-manager.c | 75 +++++++++++++++++++++++++++++++++++++++++--
 src/monitor-manager.h |  8 +++--
 src/shell.c           |  4 ++-
 3 files changed, 82 insertions(+), 5 deletions(-)

diff --git a/src/monitor-manager.c b/src/monitor-manager.c
index d42f8c40..7ee30ed2 100644
--- a/src/monitor-manager.c
+++ b/src/monitor-manager.c
@@ -37,6 +37,7 @@ typedef enum PhoshMonitorMAnagerLayoutMode {
 
 enum {
   PROP_0,
+  PROP_SENSOR_PROXY_MANAGER,
   PROP_N_MONITORS,
   PROP_LAST_PROP
 };
@@ -56,6 +57,9 @@ typedef struct _PhoshMonitorManager
 {
   PhoshDisplayDbusDisplayConfigSkeleton parent;
 
+  PhoshSensorProxyManager *sensor_proxy_manager;
+  GBinding                *sensor_proxy_binding;
+
   GPtrArray *monitors;   /* Currently known monitors */
   GPtrArray *heads;      /* Currently known heads */
 
@@ -1175,6 +1179,18 @@ static const struct zwlr_output_configuration_v1_listener config_listener = {
 };
 
 
+static void
+phosh_monitor_manager_dispose (GObject *object)
+{
+  PhoshMonitorManager *self = PHOSH_MONITOR_MANAGER (object);
+
+  g_clear_object (&self->sensor_proxy_manager);
+  g_clear_pointer (&self->sensor_proxy_binding, g_binding_unbind);
+
+  G_OBJECT_CLASS (phosh_monitor_manager_parent_class)->dispose (object);
+}
+
+
 static void
 phosh_monitor_manager_finalize (GObject *object)
 {
@@ -1190,6 +1206,25 @@ phosh_monitor_manager_finalize (GObject *object)
  * PhoshMonitorManager Class
  */
 
+static void
+phosh_monitor_manager_set_property (GObject      *object,
+                                    guint         property_id,
+                                    const GValue *value,
+                                    GParamSpec   *pspec)
+{
+  PhoshMonitorManager *self = PHOSH_MONITOR_MANAGER (object);
+
+  switch (property_id) {
+  case PROP_SENSOR_PROXY_MANAGER:
+    phosh_monitor_manager_set_sensor_proxy_manager (self, g_value_get_object (value));
+    break;
+  default:
+    G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    break;
+  }
+}
+
+
 static void
 phosh_monitor_manager_get_property (GObject    *object,
                                     guint       property_id,
@@ -1199,6 +1234,9 @@ phosh_monitor_manager_get_property (GObject    *object,
   PhoshMonitorManager *self = PHOSH_MONITOR_MANAGER (object);
 
   switch (property_id) {
+  case PROP_SENSOR_PROXY_MANAGER:
+    g_value_set_object (value, self->sensor_proxy_manager);
+    break;
   case PROP_N_MONITORS:
     g_value_set_int (value, self->monitors->len);
     break;
@@ -1265,8 +1303,18 @@ phosh_monitor_manager_class_init (PhoshMonitorManagerClass *klass)
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
 
   object_class->constructed = phosh_monitor_manager_constructed;
+  object_class->dispose = phosh_monitor_manager_dispose;
   object_class->finalize = phosh_monitor_manager_finalize;
   object_class->get_property = phosh_monitor_manager_get_property;
+  object_class->set_property = phosh_monitor_manager_set_property;
+
+  props[PROP_SENSOR_PROXY_MANAGER] =
+    g_param_spec_object ("sensor-proxy-manager",
+                         "Sensor Proxy Manager",
+                         "Sensor Proxy Manager",
+                         PHOSH_TYPE_SENSOR_PROXY_MANAGER,
+                         G_PARAM_READWRITE |
+                         G_PARAM_STATIC_STRINGS);
 
   props[PROP_N_MONITORS] =
     g_param_spec_int ("n-monitors",
@@ -1322,9 +1370,11 @@ phosh_monitor_manager_init (PhoshMonitorManager *self)
 
 
 PhoshMonitorManager *
-phosh_monitor_manager_new (void)
+phosh_monitor_manager_new (PhoshSensorProxyManager *proxy)
 {
-  return g_object_new (PHOSH_TYPE_MONITOR_MANAGER, NULL);
+  return g_object_new (PHOSH_TYPE_MONITOR_MANAGER,
+                       "sensor-proxy-manager", proxy,
+                       NULL);
 }
 
 
@@ -1444,3 +1494,24 @@ phosh_monitor_manager_apply_monitor_config (PhoshMonitorManager *self)
 
   zwlr_output_configuration_v1_apply (config);
 }
+
+void
+phosh_monitor_manager_set_sensor_proxy_manager (PhoshMonitorManager     *self,
+                                                PhoshSensorProxyManager *manager)
+{
+  g_return_if_fail (PHOSH_IS_MONITOR_MANAGER (self));
+  g_return_if_fail (PHOSH_IS_SENSOR_PROXY_MANAGER (manager) || manager == NULL);
+
+  g_clear_object (&self->sensor_proxy_manager);
+  g_clear_pointer (&self->sensor_proxy_binding, g_binding_unbind);
+
+  if (manager == NULL)
+    return;
+
+  self->sensor_proxy_manager = g_object_ref (manager);
+  self->sensor_proxy_binding = g_object_bind_property (manager, "has-accelerometer",
+                                                       self, "panel-orientation-managed",
+                                                       G_BINDING_SYNC_CREATE);
+
+
+}
diff --git a/src/monitor-manager.h b/src/monitor-manager.h
index a986d1cf..cfd10281 100644
--- a/src/monitor-manager.h
+++ b/src/monitor-manager.h
@@ -9,6 +9,9 @@
 
 #include "monitor/phosh-display-dbus.h"
 #include "monitor/monitor.h"
+
+#include "sensor-proxy-manager.h"
+
 #include <glib-object.h>
 
 G_BEGIN_DECLS
@@ -32,7 +35,7 @@ typedef enum _MetaMonitorsConfigMethod
 G_DECLARE_FINAL_TYPE (PhoshMonitorManager, phosh_monitor_manager, PHOSH, MONITOR_MANAGER,
                       PhoshDisplayDbusDisplayConfigSkeleton)
 
-PhoshMonitorManager * phosh_monitor_manager_new                       (void);
+PhoshMonitorManager * phosh_monitor_manager_new                       (PhoshSensorProxyManager *proxy);
 void                  phosh_monitor_manager_add_monitor               (PhoshMonitorManager *self,
                                                                        PhoshMonitor        *monitor);
 PhoshMonitor        * phosh_monitor_manager_get_monitor               (PhoshMonitorManager *self,
@@ -44,5 +47,6 @@ void                  phosh_monitor_manager_set_monitor_transform     (PhoshMoni
                                                                        PhoshMonitor        *monitor,
                                                                        PhoshMonitorTransform transform);
 void                  phosh_monitor_manager_apply_monitor_config      (PhoshMonitorManager *self);
-
+void                  phosh_monitor_manager_set_sensor_proxy_manager  (PhoshMonitorManager     *self,
+                                                                       PhoshSensorProxyManager *manager);
 G_END_DECLS
diff --git a/src/shell.c b/src/shell.c
index 30f9a8d9..350a40cf 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -498,6 +498,8 @@ setup_idle_cb (PhoshShell *self)
   if (priv->sensor_proxy_manager) {
     priv->proximity = phosh_proximity_new (priv->sensor_proxy_manager,
                                            priv->lockscreen_manager);
+    phosh_monitor_manager_set_sensor_proxy_manager (priv->monitor_manager,
+                                                    priv->sensor_proxy_manager);
   }
 
   priv->mount_manager = phosh_mount_manager_new ();
@@ -625,7 +627,7 @@ phosh_shell_constructed (GObject *object)
      exising toplevels */
   priv->toplevel_manager = phosh_toplevel_manager_new ();
 
-  priv->monitor_manager = phosh_monitor_manager_new ();
+  priv->monitor_manager = phosh_monitor_manager_new (NULL);
   g_signal_connect_swapped (priv->monitor_manager,
                             "monitor-removed",
                             G_CALLBACK (on_monitor_removed),
-- 
GitLab


From 1367e5e33614e20e3d21b46ea2de312f57682776 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Tue, 30 Mar 2021 16:52:37 +0200
Subject: [PATCH 20/23] monitor-manager: Delay 'monitor-added' until monitor is
 configured
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This makes is simpler for other parts of the shell since they don't
need to track this on their own.

While at that make phosh_monitor_manager_add_monitor private since
this should only happen within monitor-manager.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/monitor-manager.c | 39 ++++++++++++++++++++++++++-------------
 src/monitor-manager.h |  2 --
 2 files changed, 26 insertions(+), 15 deletions(-)

diff --git a/src/monitor-manager.c b/src/monitor-manager.c
index 7ee30ed2..32dd88e1 100644
--- a/src/monitor-manager.c
+++ b/src/monitor-manager.c
@@ -1037,6 +1037,19 @@ find_monitor_by_wl_output (PhoshMonitorManager *self, struct wl_output *output)
 }
 
 
+static void
+on_monitor_configured (PhoshMonitorManager *self, PhoshMonitor *monitor)
+{
+  g_return_if_fail (PHOSH_IS_MONITOR_MANAGER (self));
+  g_return_if_fail (PHOSH_IS_MONITOR (monitor));
+
+  g_signal_emit (self, signals[SIGNAL_MONITOR_ADDED], 0, monitor);
+  g_object_notify_by_pspec (G_OBJECT (self), props[PROP_N_MONITORS]);
+
+  g_signal_handlers_disconnect_by_data (monitor, self);
+}
+
+
 static void
 on_monitor_removed (PhoshMonitorManager *self,
                     PhoshMonitor        *monitor,
@@ -1051,6 +1064,18 @@ on_monitor_removed (PhoshMonitorManager *self,
 }
 
 
+static void
+phosh_monitor_manager_add_monitor (PhoshMonitorManager *self, PhoshMonitor *monitor)
+{
+  g_ptr_array_add (self->monitors, monitor);
+  /* Delay emmission of 'monitor-added' until it's configured */
+  g_signal_connect_swapped (monitor,
+                            "configured",
+                            G_CALLBACK (on_monitor_configured),
+                            self);
+}
+
+
 static void
 on_wl_outputs_changed (PhoshMonitorManager *self, GParamSpec *pspec, PhoshWayland *wl)
 {
@@ -1334,10 +1359,7 @@ phosh_monitor_manager_class_init (PhoshMonitorManagerClass *klass)
    * @manager: The #PhoshMonitorManager emitting the signal.
    * @monitor: The #PhoshMonitor being added.
    *
-   * Emitted whenever a monitor is about to be added. Note
-   * that the monitor might not yet be fully initialized. Use
-   * phosh_monitor_is_configured() to check or listen for
-   * the #PhoshMonitor::configured signal.
+   * Emitted whenever a monitor was added.
    */
   signals[SIGNAL_MONITOR_ADDED] = g_signal_new (
     "monitor-added",
@@ -1378,15 +1400,6 @@ phosh_monitor_manager_new (PhoshSensorProxyManager *proxy)
 }
 
 
-void
-phosh_monitor_manager_add_monitor (PhoshMonitorManager *self, PhoshMonitor *monitor)
-{
-  g_ptr_array_add (self->monitors, monitor);
-  g_signal_emit (self, signals[SIGNAL_MONITOR_ADDED], 0, monitor);
-  g_object_notify_by_pspec (G_OBJECT (self), props[PROP_N_MONITORS]);
-}
-
-
 PhoshMonitor *
 phosh_monitor_manager_get_monitor (PhoshMonitorManager *self, guint num)
 {
diff --git a/src/monitor-manager.h b/src/monitor-manager.h
index cfd10281..371c8697 100644
--- a/src/monitor-manager.h
+++ b/src/monitor-manager.h
@@ -36,8 +36,6 @@ G_DECLARE_FINAL_TYPE (PhoshMonitorManager, phosh_monitor_manager, PHOSH, MONITOR
                       PhoshDisplayDbusDisplayConfigSkeleton)
 
 PhoshMonitorManager * phosh_monitor_manager_new                       (PhoshSensorProxyManager *proxy);
-void                  phosh_monitor_manager_add_monitor               (PhoshMonitorManager *self,
-                                                                       PhoshMonitor        *monitor);
 PhoshMonitor        * phosh_monitor_manager_get_monitor               (PhoshMonitorManager *self,
                                                                        guint                num);
 guint                 phosh_monitor_manager_get_num_monitors          (PhoshMonitorManager *self);
-- 
GitLab


From 4fea7ed81c7c5b6eb2abc2d4c67f0ba4c4d68b12 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Tue, 30 Mar 2021 15:39:53 +0200
Subject: [PATCH 21/23] shell: Handle builtin monitor dynamically
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

It e.g. goes away when disabled in docked mode

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/shell.c | 137 ++++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 100 insertions(+), 37 deletions(-)

diff --git a/src/shell.c b/src/shell.c
index 350a40cf..7d3d1c07 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -87,6 +87,7 @@
 enum {
   PHOSH_SHELL_PROP_0,
   PHOSH_SHELL_PROP_LOCKED,
+  PHOSH_SHELL_PROP_BUILTIN_MONITOR,
   PHOSH_SHELL_PROP_PRIMARY_MONITOR,
   PHOSH_SHELL_PROP_SHELL_STATE,
   PHOSH_SHELL_PROP_LAST_PROP
@@ -318,6 +319,9 @@ phosh_shell_get_property (GObject *object,
   case PHOSH_SHELL_PROP_LOCKED:
     g_value_set_boolean (value, priv->locked);
     break;
+  case PHOSH_SHELL_PROP_BUILTIN_MONITOR:
+    g_value_set_object (value, phosh_shell_get_builtin_monitor (self));
+    break;
   case PHOSH_SHELL_PROP_PRIMARY_MONITOR:
     g_value_set_object (value, phosh_shell_get_primary_monitor (self));
     break;
@@ -555,6 +559,33 @@ on_builtin_monitor_power_mode_changed (PhoshShell *self, GParamSpec *pspec, Phos
   phosh_shell_set_state (self, PHOSH_STATE_BLANKED, mode == PHOSH_MONITOR_POWER_SAVE_MODE_OFF);
 }
 
+static void
+on_monitor_added (PhoshShell *self, PhoshMonitor *monitor)
+{
+  PhoshShellPrivate *priv;
+
+  g_return_if_fail (PHOSH_IS_SHELL (self));
+  g_return_if_fail (PHOSH_IS_MONITOR (monitor));
+  priv = phosh_shell_get_instance_private (self);
+
+  g_debug ("Monitor %p (%s)", monitor, monitor->name);
+
+  if (priv->builtin_monitor)
+    return;
+
+  if (!phosh_monitor_is_builtin (monitor))
+    return;
+
+  priv->builtin_monitor = g_object_ref (monitor);
+  g_signal_connect_swapped (priv->builtin_monitor,
+                            "notify::power-mode",
+                            G_CALLBACK(on_builtin_monitor_power_mode_changed),
+                            self);
+
+  g_debug ("Updating builtin monitor to %s", monitor->name);
+  g_object_notify_by_pspec (G_OBJECT (self), props[PHOSH_SHELL_PROP_BUILTIN_MONITOR]);
+}
+
 
 static void
 on_monitor_removed (PhoshShell *self, PhoshMonitor *monitor)
@@ -565,27 +596,37 @@ on_monitor_removed (PhoshShell *self, PhoshMonitor *monitor)
   g_return_if_fail (PHOSH_IS_MONITOR (monitor));
   priv = phosh_shell_get_instance_private (self);
 
-  if (priv->primary_monitor != monitor)
-    return;
+  if (priv->builtin_monitor == monitor) {
+    g_debug ("Builtin monitor %p (%s) removed", monitor, monitor->name);
 
-  g_debug ("Primary monitor removed %p", monitor);
+    if (priv->builtin_monitor) {
+      /* Power mode listener */
+      g_signal_handlers_disconnect_by_data (priv->builtin_monitor, self);
+      g_clear_object (&priv->builtin_monitor);
+    }
 
-  /* Prefer built in monitor when primary is gone... */
-  if (priv->builtin_monitor && monitor != priv->builtin_monitor) {
-    phosh_shell_set_primary_monitor (self, priv->builtin_monitor);
-    return;
+    g_object_notify_by_pspec (G_OBJECT (self), props[PHOSH_SHELL_PROP_BUILTIN_MONITOR]);
   }
 
-  /* ...just pick the first one available otherwise */
-  for (int i = 0; i < phosh_monitor_manager_get_num_monitors (priv->monitor_manager); i++) {
-    PhoshMonitor *new_primary = phosh_monitor_manager_get_monitor (priv->monitor_manager, i);
-    if (new_primary != monitor) {
-      phosh_shell_set_primary_monitor (self, new_primary);
-      break;
+  if (priv->primary_monitor == monitor) {
+    g_debug ("Primary monitor %p (%s) removed", monitor, monitor->name);
+
+    /* Prefer built in monitor when primary is gone... */
+    if (priv->builtin_monitor) {
+      phosh_shell_set_primary_monitor (self, priv->builtin_monitor);
+      return;
     }
-  }
 
-  g_assert (priv->primary_monitor && priv->primary_monitor != monitor);
+    /* ...just pick the first one available otherwise */
+    for (int i = 0; i < phosh_monitor_manager_get_num_monitors (priv->monitor_manager); i++) {
+      PhoshMonitor *new_primary = phosh_monitor_manager_get_monitor (priv->monitor_manager, i);
+      if (new_primary != monitor) {
+        phosh_shell_set_primary_monitor (self, new_primary);
+        break;
+      }
+    }
+    g_assert (priv->primary_monitor && priv->primary_monitor != monitor);
+  }
 }
 
 
@@ -602,15 +643,13 @@ find_builtin_monitor (PhoshShell *self)
     return priv->builtin_monitor;
 
   for (int i = 0; i < phosh_monitor_manager_get_num_monitors (priv->monitor_manager); i++) {
-    monitor = phosh_monitor_manager_get_monitor (priv->monitor_manager, i);
-    if (phosh_monitor_is_builtin (monitor))
+    PhoshMonitor *tmp = phosh_monitor_manager_get_monitor (priv->monitor_manager, i);
+    if (phosh_monitor_is_builtin (tmp)) {
+      monitor = tmp;
       break;
+    }
   }
 
-  if (!monitor)
-    monitor = phosh_monitor_manager_get_monitor (priv->monitor_manager, 0);
-  g_return_val_if_fail (monitor, NULL);
-
   return monitor;
 }
 
@@ -624,10 +663,14 @@ phosh_shell_constructed (GObject *object)
   G_OBJECT_CLASS (phosh_shell_parent_class)->constructed (object);
 
   /* We bind this early since a wl_display_roundtrip () would make us miss
-     exising toplevels */
+     existing toplevels */
   priv->toplevel_manager = phosh_toplevel_manager_new ();
 
   priv->monitor_manager = phosh_monitor_manager_new (NULL);
+  g_signal_connect_swapped (priv->monitor_manager,
+                            "monitor-added",
+                            G_CALLBACK (on_monitor_added),
+                            self);
   g_signal_connect_swapped (priv->monitor_manager,
                             "monitor-removed",
                             G_CALLBACK (on_monitor_removed),
@@ -636,15 +679,27 @@ phosh_shell_constructed (GObject *object)
   /* Make sure all outputs are up to date */
   phosh_wayland_roundtrip (phosh_wayland_get_default ());
 
-  if (phosh_monitor_manager_get_num_monitors(priv->monitor_manager)) {
-    priv->builtin_monitor = g_object_ref (find_builtin_monitor (self));
+  if (phosh_monitor_manager_get_num_monitors (priv->monitor_manager)) {
+    PhoshMonitor *monitor = find_builtin_monitor (self);
 
-    g_debug ("Builtin monitor is %s, %d", priv->builtin_monitor->name,
-             phosh_monitor_is_configured (priv->builtin_monitor));
+    /* Setup builtin monitor */
+    if (monitor) {
+      on_monitor_added (self, monitor);
+      g_debug ("Builtin monitor %p, configured: %d",
+               priv->builtin_monitor,
+               phosh_monitor_is_configured (priv->builtin_monitor));
+    }
+
+    /* Setup primary monitor, prefer builtin */
     /* Can't invoke phosh_shell_set_primary_monitor () since the shell
        object does not really exist yet but we need the primary monitor
        early for the panels */
-    priv->primary_monitor = g_object_ref (priv->builtin_monitor);
+    if (priv->builtin_monitor)
+      priv->primary_monitor = g_object_ref (priv->builtin_monitor);
+    else
+      priv->primary_monitor = g_object_ref (phosh_monitor_manager_get_monitor (priv->monitor_manager, 0));
+  } else {
+    g_error ("Need at least one monitor");
   }
 
   gtk_icon_theme_add_resource_path (gtk_icon_theme_get_default (),
@@ -664,15 +719,6 @@ phosh_shell_constructed (GObject *object)
   priv->polkit_auth_agent = phosh_polkit_auth_agent_new ();
 
   priv->feedback_manager = phosh_feedback_manager_new ();
-
-  if (priv->builtin_monitor) {
-    g_signal_connect_swapped (
-      priv->builtin_monitor,
-      "notify::power-mode",
-      G_CALLBACK(on_builtin_monitor_power_mode_changed),
-      self);
-  }
-
   priv->keyboard_events = phosh_keyboard_events_new ();
 
   g_idle_add ((GSourceFunc) setup_idle_cb, self);
@@ -699,6 +745,23 @@ phosh_shell_class_init (PhoshShellClass *klass)
                           FALSE,
                           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
+  /**
+   * PhoshShell:builtin-monitor:
+   *
+   * The built in monitor. This is a hardware property and hence can
+   * only be read. It can be %NULL when not present or disabled.
+   */
+  props[PHOSH_SHELL_PROP_BUILTIN_MONITOR] =
+    g_param_spec_object ("builtin-monitor",
+                         "Built in monitor",
+                         "The builtin monitor",
+                         PHOSH_TYPE_MONITOR,
+                         G_PARAM_READABLE | G_PARAM_EXPLICIT_NOTIFY | G_PARAM_STATIC_STRINGS);
+  /**
+   * PhoshShell:primary-monitor:
+   *
+   * The primary monitor that has the panels, lock screen etc. This can't be %NULL.
+   */
   props[PHOSH_SHELL_PROP_PRIMARY_MONITOR] =
     g_param_spec_object ("primary-monitor",
                          "Primary monitor",
@@ -770,7 +833,7 @@ phosh_shell_get_builtin_monitor (PhoshShell *self)
 
   g_return_val_if_fail (PHOSH_IS_SHELL (self), NULL);
   priv = phosh_shell_get_instance_private (self);
-  g_return_val_if_fail (PHOSH_IS_MONITOR (priv->builtin_monitor), NULL);
+  g_return_val_if_fail (PHOSH_IS_MONITOR (priv->builtin_monitor) || priv->builtin_monitor == NULL, NULL);
 
   return priv->builtin_monitor;
 }
-- 
GitLab


From 8f61e11267c73ce2b7b2d66874bfc8ddd87d00fa Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Tue, 30 Mar 2021 18:14:20 +0200
Subject: [PATCH 22/23] rotation-manager: Update tracked monitor
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Update tracked monitor when builtin changes. We do this explicitly
rather than listening to changes on monitor-manager since this way
the rotation-manager doesn't need to be aware that it's tracking
a built-in monitor. It just tracks what's passed in.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/rotation-manager.c | 65 ++++++++++++++++++++++++++++++------------
 src/rotation-manager.h |  2 ++
 src/shell.c            |  6 ++++
 3 files changed, 54 insertions(+), 19 deletions(-)

diff --git a/src/rotation-manager.c b/src/rotation-manager.c
index c5d8d541..9fa8abd2 100644
--- a/src/rotation-manager.c
+++ b/src/rotation-manager.c
@@ -67,7 +67,9 @@ apply_transform (PhoshRotationManager *self, PhoshMonitorTransform transform)
   PhoshMonitorManager *monitor_manager = phosh_shell_get_monitor_manager (phosh_shell_get_default());
 
   g_return_if_fail (PHOSH_IS_MONITOR_MANAGER (monitor_manager));
-  g_return_if_fail (PHOSH_IS_MONITOR (self->monitor));
+
+  if (!self->monitor)
+    return;
 
   g_debug ("Rotating %s: %d", self->monitor->name, transform);
 
@@ -229,7 +231,9 @@ fixup_lockscreen_orientation (PhoshRotationManager *self, gboolean force)
   PhoshModeManager *mode_manager = phosh_shell_get_mode_manager(shell);
 
   g_return_if_fail (PHOSH_IS_MODE_MANAGER (mode_manager));
-  g_return_if_fail (PHOSH_IS_MONITOR (self->monitor));
+
+  if (!self->monitor)
+    return;
 
   /* Only bother on phones */
   if (phosh_mode_manager_get_device_type(mode_manager) != PHOSH_MODE_DEVICE_TYPE_PHONE &&
@@ -346,8 +350,7 @@ phosh_rotation_manager_set_property (GObject      *object,
     self->lockscreen_manager = g_value_dup_object (value);
     break;
   case PROP_MONITOR:
-    /* construct only */
-    self->monitor = g_value_dup_object (value);
+    phosh_rotation_manager_set_monitor (self, g_value_get_object (value));
     break;
   case PROP_ORIENTATION_LOCKED:
     phosh_rotation_manager_set_orientation_locked (self,
@@ -414,18 +417,6 @@ phosh_rotation_manager_constructed (GObject *object)
                             self);
   on_lockscreen_manager_locked (self, NULL, self->lockscreen_manager);
 
-  g_signal_connect_swapped (self->monitor,
-                            "notify::power-mode",
-                            (GCallback) on_power_mode_changed,
-                            self);
-  on_power_mode_changed (self, NULL, self->monitor);
-
-  g_signal_connect_swapped (self->monitor,
-                            "configured",
-                            G_CALLBACK (on_monitor_configured),
-                            self);
-  on_monitor_configured (self, self->monitor);
-
   if (!self->sensor_proxy_manager) {
     g_warning ("Got not sensor-proxy, no automatic rotation");
     return;
@@ -508,7 +499,7 @@ phosh_rotation_manager_class_init (PhoshRotationManagerClass *klass)
       "Monitor",
       "The monitor to rotate",
       PHOSH_TYPE_MONITOR,
-      G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+      G_PARAM_READWRITE | G_PARAM_EXPLICIT_NOTIFY | G_PARAM_STATIC_STRINGS);
 
   props[PROP_ORIENTATION_LOCKED] =
     g_param_spec_boolean (
@@ -645,8 +636,8 @@ phosh_rotation_manager_set_transform (PhoshRotationManager   *self,
 PhoshMonitorTransform
 phosh_rotation_manager_get_transform (PhoshRotationManager *self)
 {
-  g_return_val_if_fail (PHOSH_IS_ROTATION_MANAGER (self),
-                        PHOSH_MONITOR_TRANSFORM_NORMAL);
+  g_return_val_if_fail (PHOSH_IS_ROTATION_MANAGER (self), PHOSH_MONITOR_TRANSFORM_NORMAL);
+  g_return_val_if_fail (PHOSH_IS_MONITOR (self->monitor), PHOSH_MONITOR_TRANSFORM_NORMAL);
 
   return self->monitor->transform;
 }
@@ -664,3 +655,39 @@ phosh_rotation_manager_get_monitor (PhoshRotationManager *self)
 
   return self->monitor;
 }
+
+
+void
+phosh_rotation_manager_set_monitor (PhoshRotationManager *self, PhoshMonitor *monitor)
+{
+  g_return_if_fail (PHOSH_IS_ROTATION_MANAGER (self));
+  g_return_if_fail (PHOSH_IS_MONITOR (monitor) || monitor == NULL);
+
+  g_debug ("Using monitor %p", monitor);
+
+  if (self->monitor == monitor)
+    return;
+
+  if (self->monitor) {
+    g_signal_handlers_disconnect_by_data (self->monitor, self);
+    g_clear_object (&self->monitor);
+  }
+
+  if (monitor == NULL) {
+    g_object_notify_by_pspec (G_OBJECT (self), props[PROP_MONITOR]);
+    return;
+  }
+
+  self->monitor = g_object_ref (monitor);
+  g_signal_connect_swapped (self->monitor,
+                            "notify::power-mode",
+                            G_CALLBACK (on_power_mode_changed),
+                            self);
+  on_power_mode_changed (self, NULL, self->monitor);
+
+  g_signal_connect_swapped (self->monitor,
+                            "configured",
+                            G_CALLBACK (on_monitor_configured),
+                            self);
+  g_object_notify_by_pspec (G_OBJECT (self), props[PROP_MONITOR]);
+}
diff --git a/src/rotation-manager.h b/src/rotation-manager.h
index b09926b5..4f23ea61 100644
--- a/src/rotation-manager.h
+++ b/src/rotation-manager.h
@@ -41,5 +41,7 @@ void                     phosh_rotation_manager_set_transform (PhoshRotationMana
                                                                PhoshMonitorTransform  tranform);
 PhoshMonitorTransform    phosh_rotation_manager_get_transform  (PhoshRotationManager *self);
 PhoshMonitor            *phosh_rotation_manager_get_monitor    (PhoshRotationManager *self);
+void                     phosh_rotation_manager_set_monitor    (PhoshRotationManager *self,
+                                                                PhoshMonitor *monitor);
 
 G_END_DECLS
diff --git a/src/shell.c b/src/shell.c
index 7d3d1c07..9ef6a7e4 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -583,6 +583,9 @@ on_monitor_added (PhoshShell *self, PhoshMonitor *monitor)
                             self);
 
   g_debug ("Updating builtin monitor to %s", monitor->name);
+  if (priv->rotation_manager)
+    phosh_rotation_manager_set_monitor (priv->rotation_manager, monitor);
+
   g_object_notify_by_pspec (G_OBJECT (self), props[PHOSH_SHELL_PROP_BUILTIN_MONITOR]);
 }
 
@@ -605,6 +608,9 @@ on_monitor_removed (PhoshShell *self, PhoshMonitor *monitor)
       g_clear_object (&priv->builtin_monitor);
     }
 
+    if (priv->rotation_manager)
+      phosh_rotation_manager_set_monitor (priv->rotation_manager, NULL);
+
     g_object_notify_by_pspec (G_OBJECT (self), props[PHOSH_SHELL_PROP_BUILTIN_MONITOR]);
   }
 
-- 
GitLab


From 42791321acec2e5f3dc010aefdc77d97e135adea Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Tue, 30 Mar 2021 18:21:54 +0200
Subject: [PATCH 23/23] rotateinfo: Make insensitive when built-in monitor is
 disabled
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/rotateinfo.c        | 79 ++++++++++++++++++++++++++++++++++++-----
 src/ui/settings-menu.ui |  1 +
 2 files changed, 71 insertions(+), 9 deletions(-)

diff --git a/src/rotateinfo.c b/src/rotateinfo.c
index 149b5d4d..a8e3bd20 100644
--- a/src/rotateinfo.c
+++ b/src/rotateinfo.c
@@ -23,10 +23,18 @@
  * if the output is in portrait/landscape mode.
  */
 
+enum {
+  PROP_0,
+  PROP_PRESENT,
+  PROP_LAST_PROP
+};
+static GParamSpec *props[PROP_LAST_PROP];
+
 typedef struct _PhoshRotateInfo {
-  PhoshStatusIcon     parent;
+  PhoshStatusIcon       parent;
 
   PhoshRotationManager *manager;
+  gboolean              present;
 } PhoshRotateInfo;
 
 
@@ -35,13 +43,15 @@ G_DEFINE_TYPE (PhoshRotateInfo, phosh_rotate_info, PHOSH_TYPE_STATUS_ICON)
 static void
 on_transform_changed (PhoshRotateInfo *self)
 {
-  PhoshMonitor *monitor;
+  PhoshMonitor *monitor = phosh_rotation_manager_get_monitor (self->manager);
   gboolean monitor_is_landscape;
   gboolean portrait;
 
-  if (phosh_rotation_manager_get_mode (self->manager) != PHOSH_ROTATION_MANAGER_MODE_OFF) {
+  if (phosh_rotation_manager_get_mode (self->manager) != PHOSH_ROTATION_MANAGER_MODE_OFF)
+    return;
+
+  if (!monitor)
     return;
-  }
 
   switch (phosh_rotation_manager_get_transform (self->manager)) {
   case PHOSH_MONITOR_TRANSFORM_NORMAL:
@@ -62,7 +72,6 @@ on_transform_changed (PhoshRotateInfo *self)
   }
 
   /* If we have a landscape monitor (tv, laptop) flip the rotation */
-  monitor = phosh_rotation_manager_get_monitor (self->manager);
   monitor_is_landscape = ((double)monitor->width / (double)monitor->height) > 1.0;
   portrait = monitor_is_landscape ? !portrait : portrait;
 
@@ -98,11 +107,12 @@ on_orientation_lock_changed (PhoshRotateInfo *self)
 
 
 static void
-on_mode_changed (PhoshRotateInfo *self)
+on_mode_or_monitor_changed (PhoshRotateInfo *self)
 {
   PhoshRotationManagerMode mode = phosh_rotation_manager_get_mode (self->manager);
+  gboolean present = !!phosh_rotation_manager_get_monitor (self->manager);
 
-  g_debug ("Rotation manager mode: %d", mode);
+  g_debug ("Rotation manager mode: %d, has-builtin: %d", mode, present);
   switch (mode) {
   case PHOSH_ROTATION_MANAGER_MODE_OFF:
     on_transform_changed (self);
@@ -113,12 +123,53 @@ on_mode_changed (PhoshRotateInfo *self)
   default:
     g_assert_not_reached ();
   }
+
+  if (self->present == present)
+    return;
+
+  self->present = present;
+  g_debug ("Built-in monitor present: %d", present);
+
+  g_object_notify_by_pspec (G_OBJECT (self), props[PROP_PRESENT]);
+}
+
+
+static void
+phosh_rotate_info_get_property (GObject    *object,
+                                guint       property_id,
+                                GValue     *value,
+                                GParamSpec *pspec)
+{
+  PhoshRotateInfo *self = PHOSH_ROTATE_INFO (object);
+
+  switch (property_id) {
+  case PROP_PRESENT:
+    g_value_set_boolean (value, self->present);
+    break;
+  default:
+    G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    break;
+  }
 }
 
 
 static void
 phosh_rotate_info_class_init (PhoshRotateInfoClass *klass)
 {
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->get_property = phosh_rotate_info_get_property;
+
+  props[PROP_PRESENT] =
+    g_param_spec_boolean ("present",
+                          "Present",
+                          "Whether a builtin display to rotate is present",
+                          FALSE,
+                          G_PARAM_READABLE |
+                          G_PARAM_STATIC_STRINGS |
+                          G_PARAM_EXPLICIT_NOTIFY);
+
+  g_object_class_install_properties (object_class, PROP_LAST_PROP, props);
 }
 
 
@@ -127,6 +178,10 @@ phosh_rotate_info_init (PhoshRotateInfo *self)
 {
   self->manager = phosh_shell_get_rotation_manager (phosh_shell_get_default());
 
+  phosh_status_icon_set_icon_name (PHOSH_STATUS_ICON (self), "rotation-locked-symbolic");
+  /* Translators: Automatic screen orientation is off (locked/disabled) */
+  phosh_status_icon_set_info (PHOSH_STATUS_ICON (self), _("Off"));
+
   /* We don't use property bindings since we flip info/icon based on rotation and lock */
   g_signal_connect_object (self->manager,
                            "notify::transform",
@@ -140,8 +195,14 @@ phosh_rotate_info_init (PhoshRotateInfo *self)
                            G_CONNECT_SWAPPED);
   g_signal_connect_object (self->manager,
                            "notify::mode",
-                           G_CALLBACK (on_mode_changed),
+                           G_CALLBACK (on_mode_or_monitor_changed),
+                           self,
+                           G_CONNECT_SWAPPED);
+  g_signal_connect_object (self->manager,
+                           "notify::monitor",
+                           G_CALLBACK (on_mode_or_monitor_changed),
                            self,
                            G_CONNECT_SWAPPED);
-  on_mode_changed (self);
+
+  on_mode_or_monitor_changed (self);
 }
diff --git a/src/ui/settings-menu.ui b/src/ui/settings-menu.ui
index af7ee9ce..4d9f4c8b 100644
--- a/src/ui/settings-menu.ui
+++ b/src/ui/settings-menu.ui
@@ -94,6 +94,7 @@
                   <object class="PhoshQuickSetting">
                     <property name="visible">True</property>
                     <property name="can_focus">False</property>
+                    <property name="sensitive" bind-source="rotateinfo" bind-property="present" bind-flags="sync-create"/>
                     <signal name="clicked" handler="rotation_setting_clicked_cb" object="PhoshSettings" swapped="yes"/>
                     <signal name="long-pressed" handler="rotation_setting_long_pressed_cb" object="PhoshSettings" swapped="yes"/>
                     <child>
-- 
GitLab

