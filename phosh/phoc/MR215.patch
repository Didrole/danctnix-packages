From f3952d4a583ba173a0645ce89eecc8765d94743e Mon Sep 17 00:00:00 2001
From: Clayton Craft <clayton@craftyguy.net>
Date: Sun, 18 Oct 2020 15:58:11 -0700
Subject: [PATCH 1/7] utils: apply phosh code formatting styles

This is a cosmetic change that applies code formatting styles from
Phosh's style guidelines to utils.c/h.
---
 src/utils.c | 35 ++++++++++++++++++-----------------
 src/utils.h |  2 +-
 2 files changed, 19 insertions(+), 18 deletions(-)

diff --git a/src/utils.c b/src/utils.c
index 7009315..3d63627 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -3,7 +3,8 @@
 #include <wlr/version.h>
 #include "utils.h"
 
-void phoc_utils_fix_transform(enum wl_output_transform *transform)
+void
+phoc_utils_fix_transform (enum wl_output_transform *transform)
 {
   /*
    * Starting from version 0.11.0, wlroots rotates counter-clockwise, while
@@ -12,22 +13,22 @@ void phoc_utils_fix_transform(enum wl_output_transform *transform)
    * before applying it
    */
 #if (WLR_VERSION_MAJOR > 0 || WLR_VERSION_MINOR > 10)
-  switch(*transform) {
-    case WL_OUTPUT_TRANSFORM_90:
-      *transform = WL_OUTPUT_TRANSFORM_270;
-      break;
-    case WL_OUTPUT_TRANSFORM_270:
-      *transform = WL_OUTPUT_TRANSFORM_90;
-      break;
-    case WL_OUTPUT_TRANSFORM_FLIPPED_90:
-      *transform = WL_OUTPUT_TRANSFORM_FLIPPED_270;
-      break;
-    case WL_OUTPUT_TRANSFORM_FLIPPED_270:
-      *transform = WL_OUTPUT_TRANSFORM_FLIPPED_90;
-      break;
-    default:
-      /* Nothing to be done */
-      break;
+  switch (*transform) {
+  case WL_OUTPUT_TRANSFORM_90:
+    *transform = WL_OUTPUT_TRANSFORM_270;
+    break;
+  case WL_OUTPUT_TRANSFORM_270:
+    *transform = WL_OUTPUT_TRANSFORM_90;
+    break;
+  case WL_OUTPUT_TRANSFORM_FLIPPED_90:
+    *transform = WL_OUTPUT_TRANSFORM_FLIPPED_270;
+    break;
+  case WL_OUTPUT_TRANSFORM_FLIPPED_270:
+    *transform = WL_OUTPUT_TRANSFORM_FLIPPED_90;
+    break;
+  default:
+    /* Nothing to be done */
+    break;
   }
 #endif
 }
diff --git a/src/utils.h b/src/utils.h
index 7a1262d..00f1847 100644
--- a/src/utils.h
+++ b/src/utils.h
@@ -2,4 +2,4 @@
 
 #include <wlr/types/wlr_output_layout.h>
 
-void phoc_utils_fix_transform(enum wl_output_transform *transform);
+void phoc_utils_fix_transform (enum wl_output_transform *transform);
-- 
2.26.2


From fe75b2569730b36376c433a0fc8a63b62714fec8 Mon Sep 17 00:00:00 2001
From: Clayton Craft <clayton@craftyguy.net>
Date: Sat, 17 Oct 2020 18:54:05 -0700
Subject: [PATCH 2/7] output: apply phosh code formatting styles

This is a cosmetic change that applies code formatting styles from
Phosh's style guidelines to utils.c/h.
---
 src/output.c | 1442 +++++++++++++++++++++++++++-----------------------
 src/output.h |  116 ++--
 2 files changed, 832 insertions(+), 726 deletions(-)

diff --git a/src/output.c b/src/output.c
index 267e9b0..a071641 100644
--- a/src/output.c
+++ b/src/output.c
@@ -25,552 +25,632 @@
  * Rotate a child's position relative to a parent. The parent size is (pw, ph),
  * the child position is (*sx, *sy) and its size is (sw, sh).
  */
-void rotate_child_position(double *sx, double *sy, double sw, double sh,
-		double pw, double ph, float rotation) {
-	if (rotation == 0.0) {
-		return;
-	}
-
-	// Coordinates relative to the center of the subsurface
-	double cx = *sx - pw/2 + sw/2,
-		cy = *sy - ph/2 + sh/2;
-	// Rotated coordinates
-	double rx = cos(rotation)*cx - sin(rotation)*cy,
-		ry = cos(rotation)*cy + sin(rotation)*cx;
-	*sx = rx + pw/2 - sw/2;
-	*sy = ry + ph/2 - sh/2;
+void
+rotate_child_position (double *sx, double *sy, double sw, double sh,
+                       double pw, double ph, float rotation)
+{
+  if (rotation == 0.0) {
+    return;
+  }
+
+  // Coordinates relative to the center of the subsurface
+  double cx = *sx - pw/2 + sw/2,
+         cy = *sy - ph/2 + sh/2;
+  // Rotated coordinates
+  double rx = cos (rotation)*cx - sin (rotation)*cy,
+         ry = cos (rotation)*cy + sin (rotation)*cx;
+
+  *sx = rx + pw/2 - sw/2;
+  *sy = ry + ph/2 - sh/2;
 }
 
 struct surface_iterator_data {
-	roots_surface_iterator_func_t user_iterator;
-	void *user_data;
+  roots_surface_iterator_func_t user_iterator;
+  void                         *user_data;
 
-	struct roots_output *output;
-	double ox, oy;
-	int width, height;
-	float rotation, scale;
+  struct roots_output          *output;
+  double                        ox, oy;
+  int                           width, height;
+  float                         rotation, scale;
 };
 
-static bool get_surface_box(struct surface_iterator_data *data,
-		struct wlr_surface *surface, int sx, int sy,
-		struct wlr_box *surface_box) {
-	struct roots_output *output = data->output;
-
-	if (!wlr_surface_has_buffer(surface)) {
-		return false;
-	}
-
-	int sw = surface->current.width;
-	int sh = surface->current.height;
-
-	double _sx = sx + surface->sx;
-	double _sy = sy + surface->sy;
-	rotate_child_position(&_sx, &_sy, sw, sh, data->width, data->height,
-		data->rotation);
-
-	struct wlr_box box = {
-		.x = data->ox + _sx,
-		.y = data->oy + _sy,
-		.width = sw,
-		.height = sh,
-	};
-	if (surface_box != NULL) {
-		*surface_box = box;
-	}
-
-	struct wlr_box rotated_box;
-	wlr_box_rotated_bounds(&rotated_box, &box, data->rotation);
-
-	struct wlr_box output_box = {0};
-	wlr_output_effective_resolution(output->wlr_output,
-		&output_box.width, &output_box.height);
-	scale_box(&output_box, 1 / data->scale);
-
-	struct wlr_box intersection;
-	return wlr_box_intersection(&intersection, &output_box, &rotated_box);
-}
-
-static void output_for_each_surface_iterator(struct wlr_surface *surface,
-		int sx, int sy, void *_data) {
-	struct surface_iterator_data *data = _data;
-
-	struct wlr_box box;
-	bool intersects = get_surface_box(data, surface, sx, sy, &box);
-	if (!intersects) {
-		return;
-	}
-
-	data->user_iterator(data->output, surface, &box, data->rotation,
-		data->scale, data->user_data);
-}
-
-void output_surface_for_each_surface(struct roots_output *output,
-		struct wlr_surface *surface, double ox, double oy,
-		roots_surface_iterator_func_t iterator, void *user_data) {
-	struct surface_iterator_data data = {
-		.user_iterator = iterator,
-		.user_data = user_data,
-		.output = output,
-		.ox = ox,
-		.oy = oy,
-		.width = surface->current.width,
-		.height = surface->current.height,
-		.rotation = 0,
-		.scale = 1.0
-	};
-
-	wlr_surface_for_each_surface(surface,
-		output_for_each_surface_iterator, &data);
-}
-
-void output_xdg_surface_for_each_surface(struct roots_output *output,
-		struct wlr_xdg_surface *xdg_surface, double ox, double oy,
-		roots_surface_iterator_func_t iterator, void *user_data) {
-	struct surface_iterator_data data = {
-		.user_iterator = iterator,
-		.user_data = user_data,
-		.output = output,
-		.ox = ox,
-		.oy = oy,
-		.width = xdg_surface->surface->current.width,
-		.height = xdg_surface->surface->current.height,
-		.rotation = 0,
-		.scale = 1.0
-	};
-
-	wlr_xdg_surface_for_each_surface(xdg_surface,
-		output_for_each_surface_iterator, &data);
-}
-
-void output_view_for_each_surface(struct roots_output *output,
-		struct roots_view *view, roots_surface_iterator_func_t iterator,
-		void *user_data) {
-	struct wlr_box *output_box =
-		wlr_output_layout_get_box(output->desktop->layout, output->wlr_output);
-	if (!output_box) {
-		return;
-	}
-
-	struct surface_iterator_data data = {
-		.user_iterator = iterator,
-		.user_data = user_data,
-		.output = output,
-		.ox = view->box.x - output_box->x,
-		.oy = view->box.y - output_box->y,
-		.width = view->box.width,
-		.height = view->box.height,
-		.rotation = view->rotation,
-		.scale = view->scale
-	};
-
-	view_for_each_surface(view, output_for_each_surface_iterator, &data);
+static bool
+get_surface_box (struct surface_iterator_data *data,
+                 struct wlr_surface *surface, int sx, int sy,
+                 struct wlr_box *surface_box)
+{
+  struct roots_output *output = data->output;
+
+  if (!wlr_surface_has_buffer (surface)) {
+    return false;
+  }
+
+  int sw = surface->current.width;
+  int sh = surface->current.height;
+
+  double _sx = sx + surface->sx;
+  double _sy = sy + surface->sy;
+
+  rotate_child_position (&_sx, &_sy, sw, sh, data->width, data->height,
+                         data->rotation);
+
+  struct wlr_box box = {
+    .x = data->ox + _sx,
+    .y = data->oy + _sy,
+    .width = sw,
+    .height = sh,
+  };
+
+  if (surface_box != NULL) {
+    *surface_box = box;
+  }
+
+  struct wlr_box rotated_box;
+
+  wlr_box_rotated_bounds (&rotated_box, &box, data->rotation);
+
+  struct wlr_box output_box = {0};
+
+  wlr_output_effective_resolution (output->wlr_output,
+                                   &output_box.width, &output_box.height);
+  scale_box (&output_box, 1 / data->scale);
+
+  struct wlr_box intersection;
+
+  return wlr_box_intersection (&intersection, &output_box, &rotated_box);
+}
+
+static void
+output_for_each_surface_iterator (struct wlr_surface *surface,
+                                  int sx, int sy, void *_data)
+{
+  struct surface_iterator_data *data = _data;
+
+  struct wlr_box box;
+  bool intersects = get_surface_box (data, surface, sx, sy, &box);
+
+  if (!intersects) {
+    return;
+  }
+
+  data->user_iterator (data->output, surface, &box, data->rotation,
+                       data->scale, data->user_data);
+}
+
+void
+output_surface_for_each_surface (struct roots_output *output,
+                                 struct wlr_surface *surface, double ox, double oy,
+                                 roots_surface_iterator_func_t iterator, void *user_data)
+{
+  struct surface_iterator_data data = {
+    .user_iterator = iterator,
+    .user_data = user_data,
+    .output = output,
+    .ox = ox,
+    .oy = oy,
+    .width = surface->current.width,
+    .height = surface->current.height,
+    .rotation = 0,
+    .scale = 1.0
+  };
+
+  wlr_surface_for_each_surface (surface,
+                                output_for_each_surface_iterator, &data);
+}
+
+void
+output_xdg_surface_for_each_surface (struct roots_output *output,
+                                     struct wlr_xdg_surface *xdg_surface, double ox, double oy,
+                                     roots_surface_iterator_func_t iterator, void *user_data)
+{
+  struct surface_iterator_data data = {
+    .user_iterator = iterator,
+    .user_data = user_data,
+    .output = output,
+    .ox = ox,
+    .oy = oy,
+    .width = xdg_surface->surface->current.width,
+    .height = xdg_surface->surface->current.height,
+    .rotation = 0,
+    .scale = 1.0
+  };
+
+  wlr_xdg_surface_for_each_surface (xdg_surface,
+                                    output_for_each_surface_iterator, &data);
+}
+
+void
+output_view_for_each_surface (struct roots_output *output,
+                              struct roots_view *view, roots_surface_iterator_func_t iterator,
+                              void *user_data)
+{
+  struct wlr_box *output_box =
+    wlr_output_layout_get_box (output->desktop->layout, output->wlr_output);
+
+  if (!output_box) {
+    return;
+  }
+
+  struct surface_iterator_data data = {
+    .user_iterator = iterator,
+    .user_data = user_data,
+    .output = output,
+    .ox = view->box.x - output_box->x,
+    .oy = view->box.y - output_box->y,
+    .width = view->box.width,
+    .height = view->box.height,
+    .rotation = view->rotation,
+    .scale = view->scale
+  };
+
+  view_for_each_surface (view, output_for_each_surface_iterator, &data);
 }
 
 #ifdef PHOC_XWAYLAND
-void output_xwayland_children_for_each_surface(
-		struct roots_output *output, struct wlr_xwayland_surface *surface,
-		roots_surface_iterator_func_t iterator, void *user_data) {
-	struct wlr_box *output_box =
-		wlr_output_layout_get_box(output->desktop->layout, output->wlr_output);
-	if (!output_box) {
-		return;
-	}
-
-	struct wlr_xwayland_surface *child;
-	wl_list_for_each(child, &surface->children, parent_link) {
-		if (child->mapped) {
-			double ox = child->x - output_box->x;
-			double oy = child->y - output_box->y;
-			output_surface_for_each_surface(output, child->surface,
-				ox, oy, iterator, user_data);
-		}
-		output_xwayland_children_for_each_surface(output, child,
-			iterator, user_data);
-	}
+void
+output_xwayland_children_for_each_surface (
+  struct roots_output *output, struct wlr_xwayland_surface *surface,
+  roots_surface_iterator_func_t iterator, void *user_data)
+{
+  struct wlr_box *output_box =
+    wlr_output_layout_get_box (output->desktop->layout, output->wlr_output);
+
+  if (!output_box) {
+    return;
+  }
+
+  struct wlr_xwayland_surface *child;
+
+  wl_list_for_each (child, &surface->children, parent_link) {
+    if (child->mapped) {
+      double ox = child->x - output_box->x;
+      double oy = child->y - output_box->y;
+      output_surface_for_each_surface (output, child->surface,
+                                       ox, oy, iterator, user_data);
+    }
+    output_xwayland_children_for_each_surface (output, child,
+                                               iterator, user_data);
+  }
 }
 #endif
 
-static void output_layer_handle_surface(struct roots_output *output,
-		struct roots_layer_surface *layer_surface, roots_surface_iterator_func_t iterator,
-		void *user_data) {
-	struct wlr_layer_surface_v1 *wlr_layer_surface_v1 =
-		layer_surface->layer_surface;
-	output_surface_for_each_surface(output, wlr_layer_surface_v1->surface,
-		layer_surface->geo.x, layer_surface->geo.y, iterator,
-		user_data);
-
-	struct wlr_xdg_popup *state;
-	wl_list_for_each(state, &wlr_layer_surface_v1->popups, link) {
-		struct wlr_xdg_surface *popup = state->base;
-		if (!popup->configured) {
-			continue;
-		}
-
-		double popup_sx, popup_sy;
-		popup_sx = layer_surface->geo.x;
-		popup_sx += popup->popup->geometry.x - popup->geometry.x;
-		popup_sy = layer_surface->geo.y;
-		popup_sy += popup->popup->geometry.y - popup->geometry.y;
-
-		output_xdg_surface_for_each_surface(output, popup,
-			popup_sx, popup_sy, iterator, user_data);
-	}
-}
-
-void output_layer_for_each_surface(struct roots_output *output,
-		struct wl_list *layer_surfaces, roots_surface_iterator_func_t iterator,
-		void *user_data) {
-	struct roots_layer_surface *layer_surface;
-	wl_list_for_each_reverse(layer_surface, layer_surfaces, link) {
-		if (layer_surface->layer_surface->current.exclusive_zone <= 0) {
-			output_layer_handle_surface(output, layer_surface, iterator, user_data);
-		}
-	}
-	wl_list_for_each(layer_surface, layer_surfaces, link) {
-		if (layer_surface->layer_surface->current.exclusive_zone > 0) {
-			output_layer_handle_surface(output, layer_surface, iterator, user_data);
-		}
-	}
-}
-
-void output_drag_icons_for_each_surface(struct roots_output *output,
-		PhocInput *input, roots_surface_iterator_func_t iterator,
-		void *user_data) {
-	struct wlr_box *output_box =
-		wlr_output_layout_get_box(output->desktop->layout, output->wlr_output);
-	if (!output_box) {
-		return;
-	}
-
-	struct roots_seat *seat;
-	wl_list_for_each(seat, &input->seats, link) {
-		struct roots_drag_icon *drag_icon = seat->drag_icon;
-		if (!drag_icon || !drag_icon->wlr_drag_icon->mapped) {
-			continue;
-		}
-
-		double ox = drag_icon->x - output_box->x;
-		double oy = drag_icon->y - output_box->y;
-		output_surface_for_each_surface(output,
-			drag_icon->wlr_drag_icon->surface, ox, oy, iterator, user_data);
-	}
-}
-
-void output_for_each_surface(struct roots_output *output,
-		roots_surface_iterator_func_t iterator, void *user_data) {
-	PhocDesktop *desktop = output->desktop;
-	PhocServer *server = phoc_server_get_default ();
-
-	if (output->fullscreen_view != NULL) {
-		struct roots_view *view = output->fullscreen_view;
-
-		output_view_for_each_surface(output, view, iterator, user_data);
+static void
+output_layer_handle_surface (struct roots_output *output,
+                             struct roots_layer_surface *layer_surface, roots_surface_iterator_func_t iterator,
+                             void *user_data)
+{
+  struct wlr_layer_surface_v1 *wlr_layer_surface_v1 =
+    layer_surface->layer_surface;
+
+  output_surface_for_each_surface (output, wlr_layer_surface_v1->surface,
+                                   layer_surface->geo.x, layer_surface->geo.y, iterator,
+                                   user_data);
+
+  struct wlr_xdg_popup *state;
+
+  wl_list_for_each (state, &wlr_layer_surface_v1->popups, link) {
+    struct wlr_xdg_surface *popup = state->base;
+    if (!popup->configured) {
+      continue;
+    }
+
+    double popup_sx, popup_sy;
+    popup_sx = layer_surface->geo.x;
+    popup_sx += popup->popup->geometry.x - popup->geometry.x;
+    popup_sy = layer_surface->geo.y;
+    popup_sy += popup->popup->geometry.y - popup->geometry.y;
+
+    output_xdg_surface_for_each_surface (output, popup,
+                                         popup_sx, popup_sy, iterator, user_data);
+  }
+}
+
+void
+output_layer_for_each_surface (struct roots_output *output,
+                               struct wl_list *layer_surfaces, roots_surface_iterator_func_t iterator,
+                               void *user_data)
+{
+  struct roots_layer_surface *layer_surface;
+
+  wl_list_for_each_reverse (layer_surface, layer_surfaces, link)
+  {
+    if (layer_surface->layer_surface->current.exclusive_zone <= 0) {
+      output_layer_handle_surface (output, layer_surface, iterator, user_data);
+    }
+  }
+  wl_list_for_each (layer_surface, layer_surfaces, link) {
+    if (layer_surface->layer_surface->current.exclusive_zone > 0) {
+      output_layer_handle_surface (output, layer_surface, iterator, user_data);
+    }
+  }
+}
+
+void
+output_drag_icons_for_each_surface (struct roots_output *output,
+                                    PhocInput *input, roots_surface_iterator_func_t iterator,
+                                    void *user_data)
+{
+  struct wlr_box *output_box =
+    wlr_output_layout_get_box (output->desktop->layout, output->wlr_output);
+
+  if (!output_box) {
+    return;
+  }
+
+  struct roots_seat *seat;
+
+  wl_list_for_each (seat, &input->seats, link) {
+    struct roots_drag_icon *drag_icon = seat->drag_icon;
+    if (!drag_icon || !drag_icon->wlr_drag_icon->mapped) {
+      continue;
+    }
+
+    double ox = drag_icon->x - output_box->x;
+    double oy = drag_icon->y - output_box->y;
+    output_surface_for_each_surface (output,
+                                     drag_icon->wlr_drag_icon->surface, ox, oy, iterator, user_data);
+  }
+}
+
+void
+output_for_each_surface (struct roots_output *output,
+                         roots_surface_iterator_func_t iterator, void *user_data)
+{
+  PhocDesktop *desktop = output->desktop;
+  PhocServer *server = phoc_server_get_default ();
+
+  if (output->fullscreen_view != NULL) {
+    struct roots_view *view = output->fullscreen_view;
+
+    output_view_for_each_surface (output, view, iterator, user_data);
 
 #ifdef PHOC_XWAYLAND
-		if (view->type == ROOTS_XWAYLAND_VIEW) {
-			struct roots_xwayland_surface *xwayland_surface =
-				roots_xwayland_surface_from_view(view);
-			output_xwayland_children_for_each_surface(output,
-				xwayland_surface->xwayland_surface, iterator, user_data);
-		}
+    if (view->type == ROOTS_XWAYLAND_VIEW) {
+      struct roots_xwayland_surface *xwayland_surface =
+        roots_xwayland_surface_from_view (view);
+      output_xwayland_children_for_each_surface (output,
+                                                 xwayland_surface->xwayland_surface, iterator, user_data);
+    }
 #endif
-	} else {
-		struct roots_view *view;
-		wl_list_for_each_reverse(view, &desktop->views, link) {
-			output_view_for_each_surface(output, view, iterator, user_data);
-		}
-	}
-
-	output_drag_icons_for_each_surface(output, server->input,
-		iterator, user_data);
-
-	size_t len = sizeof(output->layers) / sizeof(output->layers[0]);
-	for (size_t i = 0; i < len; ++i) {
-		output_layer_for_each_surface(output, &output->layers[i],
-			iterator, user_data);
-	}
-}
-
-static int scale_length(int length, int offset, float scale) {
-	return round((offset + length) * scale) - round(offset * scale);
-}
-
-void scale_box(struct wlr_box *box, float scale) {
-	box->width = scale_length(box->width, box->x, scale);
-	box->height = scale_length(box->height, box->y, scale);
-	box->x = round(box->x * scale);
-	box->y = round(box->y * scale);
-}
-
-void get_decoration_box(struct roots_view *view,
-		struct roots_output *output, struct wlr_box *box) {
-	struct wlr_output *wlr_output = output->wlr_output;
-
-	struct wlr_box deco_box;
-	view_get_deco_box(view, &deco_box);
-	double sx = deco_box.x - view->box.x;
-	double sy = deco_box.y - view->box.y;
-	rotate_child_position(&sx, &sy, deco_box.width, deco_box.height,
-		view->wlr_surface->current.width,
-		view->wlr_surface->current.height, view->rotation);
-	double x = sx + view->box.x;
-	double y = sy + view->box.y;
-
-	wlr_output_layout_output_coords(output->desktop->layout, wlr_output, &x, &y);
-
-	box->x = x * wlr_output->scale;
-	box->y = y * wlr_output->scale;
-	box->width = deco_box.width * wlr_output->scale;
-	box->height = deco_box.height * wlr_output->scale;
-}
-
-void output_damage_whole(struct roots_output *output) {
-	wlr_output_damage_add_whole(output->damage);
-}
-
-static bool view_accept_damage(struct roots_output *output,
-		struct roots_view *view) {
-	if (view->wlr_surface == NULL) {
-		return false;
-	}
-	if (output->fullscreen_view == NULL) {
-		return true;
-	}
-	if (output->fullscreen_view == view) {
-		return true;
-	}
+  } else {
+    struct roots_view *view;
+    wl_list_for_each_reverse (view, &desktop->views, link)
+    {
+      output_view_for_each_surface (output, view, iterator, user_data);
+    }
+  }
+
+  output_drag_icons_for_each_surface (output, server->input,
+                                      iterator, user_data);
+
+  size_t len = sizeof(output->layers) / sizeof(output->layers[0]);
+  for (size_t i = 0; i < len; ++i) {
+    output_layer_for_each_surface (output, &output->layers[i],
+                                   iterator, user_data);
+  }
+}
+
+static int
+scale_length (int length, int offset, float scale)
+{
+  return round ((offset + length) * scale) - round (offset * scale);
+}
+
+void
+scale_box (struct wlr_box *box, float scale)
+{
+  box->width = scale_length (box->width, box->x, scale);
+  box->height = scale_length (box->height, box->y, scale);
+  box->x = round (box->x * scale);
+  box->y = round (box->y * scale);
+}
+
+void
+get_decoration_box (struct roots_view *view,
+                    struct roots_output *output, struct wlr_box *box)
+{
+  struct wlr_output *wlr_output = output->wlr_output;
+
+  struct wlr_box deco_box;
+
+  view_get_deco_box (view, &deco_box);
+  double sx = deco_box.x - view->box.x;
+  double sy = deco_box.y - view->box.y;
+
+  rotate_child_position (&sx, &sy, deco_box.width, deco_box.height,
+                         view->wlr_surface->current.width,
+                         view->wlr_surface->current.height, view->rotation);
+  double x = sx + view->box.x;
+  double y = sy + view->box.y;
+
+  wlr_output_layout_output_coords (output->desktop->layout, wlr_output, &x, &y);
+
+  box->x = x * wlr_output->scale;
+  box->y = y * wlr_output->scale;
+  box->width = deco_box.width * wlr_output->scale;
+  box->height = deco_box.height * wlr_output->scale;
+}
+
+void
+output_damage_whole (struct roots_output *output)
+{
+  wlr_output_damage_add_whole (output->damage);
+}
+
+static bool
+view_accept_damage (struct roots_output *output,
+                    struct roots_view   *view)
+{
+  if (view->wlr_surface == NULL) {
+    return false;
+  }
+  if (output->fullscreen_view == NULL) {
+    return true;
+  }
+  if (output->fullscreen_view == view) {
+    return true;
+  }
 #ifdef PHOC_XWAYLAND
-	if (output->fullscreen_view->type == ROOTS_XWAYLAND_VIEW &&
-			view->type == ROOTS_XWAYLAND_VIEW) {
-		// Special case: accept damage from children
-		struct wlr_xwayland_surface *xsurface =
-			roots_xwayland_surface_from_view(view)->xwayland_surface;
-		struct wlr_xwayland_surface *fullscreen_xsurface =
-			roots_xwayland_surface_from_view(output->fullscreen_view)->xwayland_surface;
-		while (xsurface != NULL) {
-			if (fullscreen_xsurface == xsurface) {
-				return true;
-			}
-			xsurface = xsurface->parent;
-		}
-	}
+  if (output->fullscreen_view->type == ROOTS_XWAYLAND_VIEW &&
+      view->type == ROOTS_XWAYLAND_VIEW) {
+    // Special case: accept damage from children
+    struct wlr_xwayland_surface *xsurface =
+      roots_xwayland_surface_from_view (view)->xwayland_surface;
+    struct wlr_xwayland_surface *fullscreen_xsurface =
+      roots_xwayland_surface_from_view (output->fullscreen_view)->xwayland_surface;
+    while (xsurface != NULL) {
+      if (fullscreen_xsurface == xsurface) {
+        return true;
+      }
+      xsurface = xsurface->parent;
+    }
+  }
 #endif
-	return false;
+  return false;
 }
 
-static void damage_surface_iterator(struct roots_output *output,
-		struct wlr_surface *surface, struct wlr_box *_box, float rotation,
-		float scale, void *data) {
-	bool *whole = data;
+static void
+damage_surface_iterator (struct roots_output *output,
+                         struct wlr_surface *surface, struct wlr_box *_box, float rotation,
+                         float scale, void *data)
+{
+  bool *whole = data;
+
+  struct wlr_box box = *_box;
+
+  scale_box (&box, scale);
+  scale_box (&box, output->wlr_output->scale);
+
+  int center_x = box.x + box.width/2;
+  int center_y = box.y + box.height/2;
+
+  if (pixman_region32_not_empty (&surface->buffer_damage)) {
+    pixman_region32_t damage;
+    pixman_region32_init (&damage);
+    wlr_surface_get_effective_damage (surface, &damage);
+    wlr_region_scale (&damage, &damage, scale);
+    wlr_region_scale (&damage, &damage, output->wlr_output->scale);
+    if (ceil (output->wlr_output->scale) > surface->current.scale) {
+      // When scaling up a surface, it'll become blurry so we need to
+      // expand the damage region
+      wlr_region_expand (&damage, &damage,
+                         ceil (output->wlr_output->scale) - surface->current.scale);
+    }
+    pixman_region32_translate (&damage, box.x, box.y);
+    wlr_region_rotated_bounds (&damage, &damage, rotation,
+                               center_x, center_y);
+    wlr_output_damage_add (output->damage, &damage);
+    pixman_region32_fini (&damage);
+  }
+
+  if (*whole) {
+    wlr_box_rotated_bounds (&box, &box, rotation);
+    wlr_output_damage_add_box (output->damage, &box);
+  }
 
-	struct wlr_box box = *_box;
-	scale_box(&box, scale);
-	scale_box(&box, output->wlr_output->scale);
+  wlr_output_schedule_frame (output->wlr_output);
+}
 
-	int center_x = box.x + box.width/2;
-	int center_y = box.y + box.height/2;
+void
+output_damage_whole_local_surface (struct roots_output *output,
+                                   struct wlr_surface *surface, double ox, double oy)
+{
+  bool whole = true;
 
-	if (pixman_region32_not_empty(&surface->buffer_damage)) {
-		pixman_region32_t damage;
-		pixman_region32_init(&damage);
-		wlr_surface_get_effective_damage(surface, &damage);
-		wlr_region_scale(&damage, &damage, scale);
-		wlr_region_scale(&damage, &damage, output->wlr_output->scale);
-		if (ceil(output->wlr_output->scale) > surface->current.scale) {
-			// When scaling up a surface, it'll become blurry so we need to
-			// expand the damage region
-			wlr_region_expand(&damage, &damage,
-				ceil(output->wlr_output->scale) - surface->current.scale);
-		}
-		pixman_region32_translate(&damage, box.x, box.y);
-		wlr_region_rotated_bounds(&damage, &damage, rotation,
-			center_x, center_y);
-		wlr_output_damage_add(output->damage, &damage);
-		pixman_region32_fini(&damage);
-	}
-
-	if (*whole) {
-		wlr_box_rotated_bounds(&box, &box, rotation);
-		wlr_output_damage_add_box(output->damage, &box);
-	}
-
-	wlr_output_schedule_frame(output->wlr_output);
-}
-
-void output_damage_whole_local_surface(struct roots_output *output,
-		struct wlr_surface *surface, double ox, double oy) {
-	bool whole = true;
-	output_surface_for_each_surface(output, surface, ox, oy,
-		damage_surface_iterator, &whole);
-}
-
-static void damage_whole_decoration(struct roots_view *view,
-		struct roots_output *output) {
-	if (!view->decorated || view->wlr_surface == NULL) {
-		return;
-	}
-
-	struct wlr_box box;
-	get_decoration_box(view, output, &box);
-
-	wlr_box_rotated_bounds(&box, &box, view->rotation);
-
-	wlr_output_damage_add_box(output->damage, &box);
-}
-
-void output_damage_whole_view(struct roots_output *output,
-		struct roots_view *view) {
-	if (!view_accept_damage(output, view)) {
-		return;
-	}
-
-	damage_whole_decoration(view, output);
-
-	bool whole = true;
-	output_view_for_each_surface(output, view, damage_surface_iterator, &whole);
-}
-
-void output_damage_whole_drag_icon(struct roots_output *output,
-		struct roots_drag_icon *icon) {
-	bool whole = true;
-	output_surface_for_each_surface(output, icon->wlr_drag_icon->surface,
-		icon->x, icon->y, damage_surface_iterator, &whole);
-}
-
-void output_damage_from_local_surface(struct roots_output *output,
-		struct wlr_surface *surface, double ox, double oy) {
-	bool whole = false;
-	output_surface_for_each_surface(output, surface, ox, oy,
-		damage_surface_iterator, &whole);
-}
-
-void output_damage_from_view(struct roots_output *output,
-		struct roots_view *view) {
-	if (!view_accept_damage(output, view)) {
-		return;
-	}
-
-	bool whole = false;
-	output_view_for_each_surface(output, view, damage_surface_iterator, &whole);
-}
-
-static void set_mode(struct wlr_output *output,
-		struct roots_output_config *oc) {
-	int mhz = (int)(oc->mode.refresh_rate * 1000);
-
-	if (wl_list_empty(&output->modes)) {
-		// Output has no mode, try setting a custom one
-		wlr_output_set_custom_mode(output, oc->mode.width, oc->mode.height, mhz);
-		return;
-	}
-
-	struct wlr_output_mode *mode, *best = NULL;
-	wl_list_for_each(mode, &output->modes, link) {
-		if (mode->width == oc->mode.width && mode->height == oc->mode.height) {
-			if (mode->refresh == mhz) {
-				best = mode;
-				break;
-			}
-			best = mode;
-		}
-	}
-	if (!best) {
-		wlr_log(WLR_ERROR, "Configured mode for %s not available", output->name);
-	} else {
-		wlr_log(WLR_DEBUG, "Assigning configured mode to %s", output->name);
-		wlr_output_set_mode(output, best);
-	}
-}
-
-static void update_output_manager_config(PhocDesktop *desktop) {
-	struct wlr_output_configuration_v1 *config =
-		wlr_output_configuration_v1_create();
-
-	struct roots_output *output;
-	wl_list_for_each(output, &desktop->outputs, link) {
-		struct wlr_output_configuration_head_v1 *config_head =
-			wlr_output_configuration_head_v1_create(config, output->wlr_output);
-		struct wlr_box *output_box = wlr_output_layout_get_box(
-			output->desktop->layout, output->wlr_output);
-		if (output_box) {
-			config_head->state.x = output_box->x;
-			config_head->state.y = output_box->y;
-		}
-	}
-
-	wlr_output_manager_v1_set_configuration(desktop->output_manager_v1, config);
-}
-
-void handle_output_manager_apply(struct wl_listener *listener, void *data) {
-	PhocDesktop *desktop =
-		wl_container_of(listener, desktop, output_manager_apply);
-	struct wlr_output_configuration_v1 *config = data;
-
-	bool ok = true;
-	struct wlr_output_configuration_head_v1 *config_head;
-	// First disable outputs we need to disable
-	wl_list_for_each(config_head, &config->heads, link) {
-		struct wlr_output *wlr_output = config_head->state.output;
-		if (config_head->state.enabled)
-			continue;
-
-		if (!wlr_output->enabled)
-			continue;
-
-		wlr_output_enable(wlr_output, false);
-		wlr_output_layout_remove(desktop->layout, wlr_output);
-		ok &= wlr_output_commit(wlr_output);
-	}
-
-	// Then enable outputs that need to
-	wl_list_for_each(config_head, &config->heads, link) {
-		struct wlr_output *wlr_output = config_head->state.output;
-
-		if (!config_head->state.enabled)
-			continue;
-
-		wlr_output_enable(wlr_output, true);
-		if (config_head->state.mode != NULL) {
-			wlr_output_set_mode(wlr_output, config_head->state.mode);
-		} else {
-			wlr_output_set_custom_mode(wlr_output,
-				config_head->state.custom_mode.width,
-				config_head->state.custom_mode.height,
-				config_head->state.custom_mode.refresh);
-		}
-		wlr_output_layout_add(desktop->layout, wlr_output,
-			config_head->state.x, config_head->state.y);
-		wlr_output_set_transform(wlr_output, config_head->state.transform);
-		wlr_output_set_scale(wlr_output, config_head->state.scale);
-		struct roots_output *output = wlr_output->data;
-		ok &= wlr_output_commit(wlr_output);
-		if (output->fullscreen_view) {
-			view_set_fullscreen(output->fullscreen_view, true, wlr_output);
-		}
-	}
-
-	if (ok) {
-		wlr_output_configuration_v1_send_succeeded(config);
-	} else {
-		wlr_output_configuration_v1_send_failed(config);
-	}
-	wlr_output_configuration_v1_destroy(config);
-
-	update_output_manager_config(desktop);
-}
-
-void handle_output_manager_test(struct wl_listener *listener, void *data) {
-	PhocDesktop *desktop =
-		wl_container_of(listener, desktop, output_manager_test);
-	struct wlr_output_configuration_v1 *config = data;
-
-	// TODO: implement test-only mode
-	wlr_output_configuration_v1_send_succeeded(config);
-	wlr_output_configuration_v1_destroy(config);
+  output_surface_for_each_surface (output, surface, ox, oy,
+                                   damage_surface_iterator, &whole);
+}
+
+static void
+damage_whole_decoration (struct roots_view   *view,
+                         struct roots_output *output)
+{
+  if (!view->decorated || view->wlr_surface == NULL) {
+    return;
+  }
+
+  struct wlr_box box;
+
+  get_decoration_box (view, output, &box);
+
+  wlr_box_rotated_bounds (&box, &box, view->rotation);
+
+  wlr_output_damage_add_box (output->damage, &box);
+}
+
+void
+output_damage_whole_view (struct roots_output *output,
+                          struct roots_view   *view)
+{
+  if (!view_accept_damage (output, view)) {
+    return;
+  }
+
+  damage_whole_decoration (view, output);
+
+  bool whole = true;
+
+  output_view_for_each_surface (output, view, damage_surface_iterator, &whole);
 }
 
 void
-phoc_output_handle_output_power_manager_set_mode(struct wl_listener *listener, void *data)
+output_damage_whole_drag_icon (struct roots_output    *output,
+                               struct roots_drag_icon *icon)
+{
+  bool whole = true;
+
+  output_surface_for_each_surface (output, icon->wlr_drag_icon->surface,
+                                   icon->x, icon->y, damage_surface_iterator, &whole);
+}
+
+void
+output_damage_from_local_surface (struct roots_output *output,
+                                  struct wlr_surface *surface, double ox, double oy)
+{
+  bool whole = false;
+
+  output_surface_for_each_surface (output, surface, ox, oy,
+                                   damage_surface_iterator, &whole);
+}
+
+void
+output_damage_from_view (struct roots_output *output,
+                         struct roots_view   *view)
+{
+  if (!view_accept_damage (output, view)) {
+    return;
+  }
+
+  bool whole = false;
+
+  output_view_for_each_surface (output, view, damage_surface_iterator, &whole);
+}
+
+static void
+set_mode (struct wlr_output          *output,
+          struct roots_output_config *oc)
+{
+  int mhz = (int)(oc->mode.refresh_rate * 1000);
+
+  if (wl_list_empty (&output->modes)) {
+    // Output has no mode, try setting a custom one
+    wlr_output_set_custom_mode (output, oc->mode.width, oc->mode.height, mhz);
+    return;
+  }
+
+  struct wlr_output_mode *mode, *best = NULL;
+
+  wl_list_for_each (mode, &output->modes, link) {
+    if (mode->width == oc->mode.width && mode->height == oc->mode.height) {
+      if (mode->refresh == mhz) {
+        best = mode;
+        break;
+      }
+      best = mode;
+    }
+  }
+  if (!best) {
+    wlr_log (WLR_ERROR, "Configured mode for %s not available", output->name);
+  } else {
+    wlr_log (WLR_DEBUG, "Assigning configured mode to %s", output->name);
+    wlr_output_set_mode (output, best);
+  }
+}
+
+static void
+update_output_manager_config (PhocDesktop *desktop)
+{
+  struct wlr_output_configuration_v1 *config =
+    wlr_output_configuration_v1_create ();
+
+  struct roots_output *output;
+
+  wl_list_for_each (output, &desktop->outputs, link) {
+    struct wlr_output_configuration_head_v1 *config_head =
+      wlr_output_configuration_head_v1_create (config, output->wlr_output);
+    struct wlr_box *output_box = wlr_output_layout_get_box (
+      output->desktop->layout, output->wlr_output);
+    if (output_box) {
+      config_head->state.x = output_box->x;
+      config_head->state.y = output_box->y;
+    }
+  }
+
+  wlr_output_manager_v1_set_configuration (desktop->output_manager_v1, config);
+}
+
+void
+handle_output_manager_apply (struct wl_listener *listener, void *data)
+{
+  PhocDesktop *desktop =
+    wl_container_of (listener, desktop, output_manager_apply);
+  struct wlr_output_configuration_v1 *config = data;
+
+  bool ok = true;
+  struct wlr_output_configuration_head_v1 *config_head;
+
+  // First disable outputs we need to disable
+  wl_list_for_each (config_head, &config->heads, link) {
+    struct wlr_output *wlr_output = config_head->state.output;
+
+    if (config_head->state.enabled)
+      continue;
+
+    if (!wlr_output->enabled)
+      continue;
+
+    wlr_output_enable (wlr_output, false);
+    wlr_output_layout_remove (desktop->layout, wlr_output);
+    ok &= wlr_output_commit (wlr_output);
+  }
+
+  // Then enable outputs that need to
+  wl_list_for_each (config_head, &config->heads, link) {
+    struct wlr_output *wlr_output = config_head->state.output;
+
+    if (!config_head->state.enabled)
+      continue;
+
+    wlr_output_enable (wlr_output, true);
+    if (config_head->state.mode != NULL) {
+      wlr_output_set_mode (wlr_output, config_head->state.mode);
+    } else {
+      wlr_output_set_custom_mode (wlr_output,
+                                  config_head->state.custom_mode.width,
+                                  config_head->state.custom_mode.height,
+                                  config_head->state.custom_mode.refresh);
+    }
+    wlr_output_layout_add (desktop->layout, wlr_output,
+                           config_head->state.x, config_head->state.y);
+    wlr_output_set_transform (wlr_output, config_head->state.transform);
+    wlr_output_set_scale (wlr_output, config_head->state.scale);
+    ok &= wlr_output_commit (wlr_output);
+  }
+
+  if (ok) {
+    wlr_output_configuration_v1_send_succeeded (config);
+  } else {
+    wlr_output_configuration_v1_send_failed (config);
+  }
+  wlr_output_configuration_v1_destroy (config);
+
+  update_output_manager_config (desktop);
+}
+
+void
+handle_output_manager_test (struct wl_listener *listener, void *data)
+{
+  PhocDesktop *desktop =
+    wl_container_of (listener, desktop, output_manager_test);
+  struct wlr_output_configuration_v1 *config = data;
+
+  // TODO: implement test-only mode
+  wlr_output_configuration_v1_send_succeeded (config);
+  wlr_output_configuration_v1_destroy (config);
+}
+
+void
+phoc_output_handle_output_power_manager_set_mode (struct wl_listener *listener, void *data)
 {
   struct wlr_output_power_v1_set_mode_event *event = data;
   struct roots_output *self;
@@ -580,7 +660,7 @@ phoc_output_handle_output_power_manager_set_mode(struct wl_listener *listener, v
 
   self = event->output->data;
   g_debug ("Request to set output power mode of %p to %d",
-	   self, event->mode);
+           self, event->mode);
   switch (event->mode) {
   case ZWLR_OUTPUT_POWER_V1_MODE_OFF:
     enable = false;
@@ -596,8 +676,8 @@ phoc_output_handle_output_power_manager_set_mode(struct wl_listener *listener, v
   if (enable == self->wlr_output->enabled)
     return;
 
-  wlr_output_enable(self->wlr_output, enable);
-  if (!wlr_output_commit(self->wlr_output)) {
+  wlr_output_enable (self->wlr_output, enable);
+  if (!wlr_output_commit (self->wlr_output)) {
     g_warning ("Failed to commit power mode change to %d for %p", enable, self);
     return;
   }
@@ -606,151 +686,177 @@ phoc_output_handle_output_power_manager_set_mode(struct wl_listener *listener, v
     output_damage_whole (self);
 }
 
-static void output_destroy(struct roots_output *output) {
-	// TODO: cursor
-	//example_config_configure_cursor(sample->config, sample->cursor,
-	//	sample->compositor);
+static void
+output_destroy (struct roots_output *output)
+{
+  // TODO: cursor
+  // example_config_configure_cursor(sample->config, sample->cursor,
+  //	sample->compositor);
+
+  wl_list_remove (&output->link);
+  wl_list_remove (&output->destroy.link);
+  wl_list_remove (&output->enable.link);
+  wl_list_remove (&output->mode.link);
+  wl_list_remove (&output->transform.link);
+  wl_list_remove (&output->damage_frame.link);
+  wl_list_remove (&output->damage_destroy.link);
+  free (output);
+}
+
+static void
+output_handle_destroy (struct wl_listener *listener, void *data)
+{
+  struct roots_output *output = wl_container_of (listener, output, destroy);
+  PhocDesktop *desktop = output->desktop;
+
+  output_destroy (output);
+  update_output_manager_config (desktop);
+}
+
+static void
+output_handle_enable (struct wl_listener *listener, void *data)
+{
+  struct roots_output *output = wl_container_of (listener, output, enable);
+
+  update_output_manager_config (output->desktop);
+}
+
+static void
+output_damage_handle_frame (struct wl_listener *listener,
+                            void               *data)
+{
+  struct roots_output *output =
+    wl_container_of (listener, output, damage_frame);
+
+  output_render (output);
+}
+
+static void
+output_damage_handle_destroy (struct wl_listener *listener,
+                              void               *data)
+{
+  struct roots_output *output =
+    wl_container_of (listener, output, damage_destroy);
+
+  output_destroy (output);
+}
+
+static void
+output_handle_mode (struct wl_listener *listener, void *data)
+{
+  struct roots_output *output =
+    wl_container_of (listener, output, mode);
+
+  arrange_layers (output);
+  update_output_manager_config (output->desktop);
+}
+
+static void
+output_handle_transform (struct wl_listener *listener, void *data)
+{
+  struct roots_output *output =
+    wl_container_of (listener, output, transform);
+
+  arrange_layers (output);
+}
+
+void
+handle_new_output (struct wl_listener *listener, void *data)
+{
+  PhocDesktop *desktop = wl_container_of (listener, desktop,
+                                          new_output);
+  struct wlr_output *wlr_output = data;
+  PhocServer *server = phoc_server_get_default ();
+  PhocInput *input = server->input;
+  struct roots_config *config = desktop->config;
+
+  wlr_log (WLR_DEBUG, "Output '%s' added", wlr_output->name);
+  wlr_log (WLR_DEBUG, "'%s %s %s' %" PRId32 "mm x %" PRId32 "mm", wlr_output->make,
+           wlr_output->model, wlr_output->serial, wlr_output->phys_width,
+           wlr_output->phys_height);
+
+  struct roots_output *output = calloc (1, sizeof(struct roots_output));
+
+  clock_gettime (CLOCK_MONOTONIC, &output->last_frame);
+  output->desktop = desktop;
+  output->wlr_output = wlr_output;
+  wlr_output->data = output;
+  wl_list_insert (&desktop->outputs, &output->link);
+
+  output->damage = wlr_output_damage_create (wlr_output);
+
+  output->debug_touch_points = NULL;
+
+  output->destroy.notify = output_handle_destroy;
+  wl_signal_add (&wlr_output->events.destroy, &output->destroy);
+  output->enable.notify = output_handle_enable;
+  wl_signal_add (&wlr_output->events.enable, &output->enable);
+  output->mode.notify = output_handle_mode;
+  wl_signal_add (&wlr_output->events.mode, &output->mode);
+  output->transform.notify = output_handle_transform;
+  wl_signal_add (&wlr_output->events.transform, &output->transform);
+
+  output->damage_frame.notify = output_damage_handle_frame;
+  wl_signal_add (&output->damage->events.frame, &output->damage_frame);
+  output->damage_destroy.notify = output_damage_handle_destroy;
+  wl_signal_add (&output->damage->events.destroy, &output->damage_destroy);
+
+  size_t len = sizeof(output->layers) / sizeof(output->layers[0]);
+
+  for (size_t i = 0; i < len; ++i) {
+    wl_list_init (&output->layers[i]);
+  }
+
+  struct roots_output_config *output_config =
+    roots_config_get_output (config, wlr_output);
+
+  struct wlr_output_mode *preferred_mode =
+    wlr_output_preferred_mode (wlr_output);
+
+  if (output_config) {
+    if (output_config->enable) {
+      if (wlr_output_is_drm (wlr_output)) {
+        struct roots_output_mode_config *mode_config;
+        wl_list_for_each (mode_config, &output_config->modes, link) {
+          wlr_drm_connector_add_mode (wlr_output, &mode_config->info);
+        }
+      } else if (!wl_list_empty (&output_config->modes)) {
+        wlr_log (WLR_ERROR, "Can only add modes for DRM backend");
+      }
+
+      if (output_config->mode.width) {
+        set_mode (wlr_output, output_config);
+      } else if (preferred_mode != NULL) {
+        wlr_output_set_mode (wlr_output, preferred_mode);
+      }
+
+      wlr_output_set_scale (wlr_output, output_config->scale);
+      wlr_output_set_transform (wlr_output, output_config->transform);
+      wlr_output_layout_add (desktop->layout, wlr_output, output_config->x,
+                             output_config->y);
+    } else {
+      wlr_output_enable (wlr_output, false);
+    }
+  } else {
+    if (preferred_mode != NULL) {
+      wlr_output_set_mode (wlr_output, preferred_mode);
+    }
+    wlr_output_enable (wlr_output, true);
+    wlr_output_layout_add_auto (desktop->layout, wlr_output);
+  }
+  wlr_output_commit (wlr_output);
+
+  struct roots_seat *seat;
+
+  wl_list_for_each (seat, &input->seats, link) {
+    roots_seat_configure_cursor (seat);
+    roots_seat_configure_xcursor (seat);
+  }
+
+  arrange_layers (output);
+  output_damage_whole (output);
 
-	wl_list_remove(&output->link);
-	wl_list_remove(&output->destroy.link);
-	wl_list_remove(&output->enable.link);
-	wl_list_remove(&output->mode.link);
-	wl_list_remove(&output->transform.link);
-	wl_list_remove(&output->damage_frame.link);
-	wl_list_remove(&output->damage_destroy.link);
-	free(output);
-}
-
-static void output_handle_destroy(struct wl_listener *listener, void *data) {
-	struct roots_output *output = wl_container_of(listener, output, destroy);
-	PhocDesktop *desktop = output->desktop;
-	output_destroy(output);
-	update_output_manager_config(desktop);
-}
-
-static void output_handle_enable(struct wl_listener *listener, void *data) {
-	struct roots_output *output = wl_container_of(listener, output, enable);
-	update_output_manager_config(output->desktop);
-}
-
-static void output_damage_handle_frame(struct wl_listener *listener,
-		void *data) {
-	struct roots_output *output =
-		wl_container_of(listener, output, damage_frame);
-	output_render(output);
-}
-
-static void output_damage_handle_destroy(struct wl_listener *listener,
-		void *data) {
-	struct roots_output *output =
-		wl_container_of(listener, output, damage_destroy);
-	output_destroy(output);
-}
-
-static void output_handle_mode(struct wl_listener *listener, void *data) {
-	struct roots_output *output =
-		wl_container_of(listener, output, mode);
-	arrange_layers(output);
-	update_output_manager_config(output->desktop);
-}
-
-static void output_handle_transform(struct wl_listener *listener, void *data) {
-	struct roots_output *output =
-		wl_container_of(listener, output, transform);
-	arrange_layers(output);
-}
-
-void handle_new_output(struct wl_listener *listener, void *data) {
-	PhocDesktop *desktop = wl_container_of(listener, desktop,
-		new_output);
-	struct wlr_output *wlr_output = data;
-	PhocServer *server = phoc_server_get_default ();
-	PhocInput *input = server->input;
-	struct roots_config *config = desktop->config;
-
-	wlr_log(WLR_DEBUG, "Output '%s' added", wlr_output->name);
-	wlr_log(WLR_DEBUG, "'%s %s %s' %"PRId32"mm x %"PRId32"mm", wlr_output->make,
-		wlr_output->model, wlr_output->serial, wlr_output->phys_width,
-		wlr_output->phys_height);
-
-	struct roots_output *output = calloc(1, sizeof(struct roots_output));
-	clock_gettime(CLOCK_MONOTONIC, &output->last_frame);
-	output->desktop = desktop;
-	output->wlr_output = wlr_output;
-	wlr_output->data = output;
-	wl_list_insert(&desktop->outputs, &output->link);
-
-	output->damage = wlr_output_damage_create(wlr_output);
-
-	output->debug_touch_points = NULL;
-
-	output->destroy.notify = output_handle_destroy;
-	wl_signal_add(&wlr_output->events.destroy, &output->destroy);
-	output->enable.notify = output_handle_enable;
-	wl_signal_add(&wlr_output->events.enable, &output->enable);
-	output->mode.notify = output_handle_mode;
-	wl_signal_add(&wlr_output->events.mode, &output->mode);
-	output->transform.notify = output_handle_transform;
-	wl_signal_add(&wlr_output->events.transform, &output->transform);
-
-	output->damage_frame.notify = output_damage_handle_frame;
-	wl_signal_add(&output->damage->events.frame, &output->damage_frame);
-	output->damage_destroy.notify = output_damage_handle_destroy;
-	wl_signal_add(&output->damage->events.destroy, &output->damage_destroy);
-
-	size_t len = sizeof(output->layers) / sizeof(output->layers[0]);
-	for (size_t i = 0; i < len; ++i) {
-		wl_list_init(&output->layers[i]);
-	}
-
-	struct roots_output_config *output_config =
-		roots_config_get_output(config, wlr_output);
-
-	struct wlr_output_mode *preferred_mode =
-		wlr_output_preferred_mode(wlr_output);
-	if (output_config) {
-		if (output_config->enable) {
-			if (wlr_output_is_drm(wlr_output)) {
-				struct roots_output_mode_config *mode_config;
-				wl_list_for_each(mode_config, &output_config->modes, link) {
-					wlr_drm_connector_add_mode(wlr_output, &mode_config->info);
-				}
-			} else if (!wl_list_empty(&output_config->modes)) {
-				wlr_log(WLR_ERROR, "Can only add modes for DRM backend");
-			}
-
-			if (output_config->mode.width) {
-				set_mode(wlr_output, output_config);
-			} else if (preferred_mode != NULL) {
-				wlr_output_set_mode(wlr_output, preferred_mode);
-			}
-
-			wlr_output_set_scale(wlr_output, output_config->scale);
-			wlr_output_set_transform(wlr_output, output_config->transform);
-			wlr_output_layout_add(desktop->layout, wlr_output, output_config->x,
-				output_config->y);
-		} else {
-			wlr_output_enable(wlr_output, false);
-		}
-	} else {
-		if (preferred_mode != NULL) {
-			wlr_output_set_mode(wlr_output, preferred_mode);
-		}
-		wlr_output_enable(wlr_output, true);
-		wlr_output_layout_add_auto(desktop->layout, wlr_output);
-	}
-	wlr_output_commit(wlr_output);
-
-	struct roots_seat *seat;
-	wl_list_for_each(seat, &input->seats, link) {
-		roots_seat_configure_cursor(seat);
-		roots_seat_configure_xcursor(seat);
-	}
-
-	arrange_layers(output);
-	output_damage_whole(output);
-
-	update_output_manager_config(desktop);
+  update_output_manager_config (desktop);
 }
 
 /**
diff --git a/src/output.h b/src/output.h
index 79632c9..3b5e53a 100644
--- a/src/output.h
+++ b/src/output.h
@@ -10,82 +10,82 @@
 #include <wlr/types/wlr_output_damage.h>
 
 struct roots_output {
-	PhocDesktop *desktop;
-	struct wlr_output *wlr_output;
-	struct wl_list link; // roots_desktop:outputs
+  PhocDesktop              *desktop;
+  struct wlr_output        *wlr_output;
+  struct wl_list            link; // roots_desktop:outputs
 
-	struct roots_view *fullscreen_view;
-	struct wl_list layers[4]; // layer_surface::link
-	bool force_shell_reveal;
+  struct roots_view        *fullscreen_view;
+  struct wl_list            layers[4]; // layer_surface::link
+  bool                      force_shell_reveal;
 
-	struct timespec last_frame;
-	struct wlr_output_damage *damage;
-	GList *debug_touch_points;
+  struct timespec           last_frame;
+  struct wlr_output_damage *damage;
+  GList                    *debug_touch_points;
 
-	struct wlr_box usable_area;
+  struct wlr_box            usable_area;
 
-	struct wl_listener destroy;
-	struct wl_listener enable;
-	struct wl_listener mode;
-	struct wl_listener transform;
-	struct wl_listener damage_frame;
-	struct wl_listener damage_destroy;
+  struct wl_listener        destroy;
+  struct wl_listener        enable;
+  struct wl_listener        mode;
+  struct wl_listener        transform;
+  struct wl_listener        damage_frame;
+  struct wl_listener        damage_destroy;
 };
 
 typedef void (*roots_surface_iterator_func_t)(struct roots_output *output,
-	struct wlr_surface *surface, struct wlr_box *box, float rotation,
-	float scale, void *user_data);
+                                              struct wlr_surface *surface, struct wlr_box *box, float rotation,
+                                              float scale, void *user_data);
 
-void rotate_child_position(double *sx, double *sy, double sw, double sh,
-	double pw, double ph, float rotation);
+void     rotate_child_position (double *sx, double *sy, double sw, double sh,
+                                double pw, double ph, float rotation);
 
-void output_surface_for_each_surface(struct roots_output *output,
-	struct wlr_surface *surface, double ox, double oy,
-	roots_surface_iterator_func_t iterator, void *user_data);
-void output_xdg_surface_for_each_surface(struct roots_output *output,
-	struct wlr_xdg_surface *xdg_surface, double ox, double oy,
-	roots_surface_iterator_func_t iterator, void *user_data);
-void output_view_for_each_surface(struct roots_output *output,
-	struct roots_view *view, roots_surface_iterator_func_t iterator,
-	void *user_data);
-void output_drag_icons_for_each_surface(struct roots_output *output,
-	PhocInput *input, roots_surface_iterator_func_t iterator,
-	void *user_data);
-void output_layer_for_each_surface(struct roots_output *output,
-	struct wl_list *layer_surfaces, roots_surface_iterator_func_t iterator,
-	void *user_data);
+void     output_surface_for_each_surface (struct roots_output *output,
+                                          struct wlr_surface *surface, double ox, double oy,
+                                          roots_surface_iterator_func_t iterator, void *user_data);
+void     output_xdg_surface_for_each_surface (struct roots_output *output,
+                                              struct wlr_xdg_surface *xdg_surface, double ox, double oy,
+                                              roots_surface_iterator_func_t iterator, void *user_data);
+void     output_view_for_each_surface (struct roots_output *output,
+                                       struct roots_view *view, roots_surface_iterator_func_t iterator,
+                                       void *user_data);
+void     output_drag_icons_for_each_surface (struct roots_output *output,
+                                             PhocInput *input, roots_surface_iterator_func_t iterator,
+                                             void *user_data);
+void     output_layer_for_each_surface (struct roots_output *output,
+                                        struct wl_list *layer_surfaces, roots_surface_iterator_func_t iterator,
+                                        void *user_data);
 #ifdef PHOC_XWAYLAND
 struct wlr_xwayland_surface;
-void output_xwayland_children_for_each_surface(
-	struct roots_output *output, struct wlr_xwayland_surface *surface,
-	roots_surface_iterator_func_t iterator, void *user_data);
+void     output_xwayland_children_for_each_surface (
+  struct roots_output *output, struct wlr_xwayland_surface *surface,
+  roots_surface_iterator_func_t iterator, void *user_data);
 #endif
-void output_for_each_surface(struct roots_output *output,
-	roots_surface_iterator_func_t iterator, void *user_data);
+void     output_for_each_surface (struct roots_output *output,
+                                  roots_surface_iterator_func_t iterator, void *user_data);
 
-void handle_new_output(struct wl_listener *listener, void *data);
-void handle_output_manager_apply(struct wl_listener *listener, void *data);
-void handle_output_manager_test(struct wl_listener *listener, void *data);
-void phoc_output_handle_output_power_manager_set_mode(struct wl_listener *listener, void *data);
+void     handle_new_output (struct wl_listener *listener, void *data);
+void     handle_output_manager_apply (struct wl_listener *listener, void *data);
+void     handle_output_manager_test (struct wl_listener *listener, void *data);
+void     phoc_output_handle_output_power_manager_set_mode (struct wl_listener *listener, void *data);
 
 struct roots_view;
 struct roots_drag_icon;
 
-void output_damage_whole(struct roots_output *output);
-void output_damage_whole_view(struct roots_output *output,
-	struct roots_view *view);
-void output_damage_from_view(struct roots_output *output,
-	struct roots_view *view);
-void output_damage_whole_drag_icon(struct roots_output *output,
-	struct roots_drag_icon *icon);
-void output_damage_from_local_surface(struct roots_output *output,
-	struct wlr_surface *surface, double ox, double oy);
-void output_damage_whole_local_surface(struct roots_output *output,
-	struct wlr_surface *surface, double ox, double oy);
+void     output_damage_whole (struct roots_output *output);
+void     output_damage_whole_view (struct roots_output *output,
+                                   struct roots_view   *view);
+void     output_damage_from_view (struct roots_output *output,
+                                  struct roots_view   *view);
+void     output_damage_whole_drag_icon (struct roots_output    *output,
+                                        struct roots_drag_icon *icon);
+void     output_damage_from_local_surface (struct roots_output *output,
+                                           struct wlr_surface *surface, double ox, double oy);
+void     output_damage_whole_local_surface (struct roots_output *output,
+                                            struct wlr_surface *surface, double ox, double oy);
 
-void scale_box(struct wlr_box *box, float scale);
-void get_decoration_box(struct roots_view *view,
-	struct roots_output *output, struct wlr_box *box);
+void     scale_box (struct wlr_box *box, float scale);
+void     get_decoration_box (struct roots_view *view,
+                             struct roots_output *output, struct wlr_box *box);
 gboolean phoc_output_is_builtin (struct roots_output *self);
 
 #endif
-- 
2.26.2


From 2a37522382ab5c5425a649aa729f8e8d3a0ab5fa Mon Sep 17 00:00:00 2001
From: Clayton Craft <clayton@craftyguy.net>
Date: Sun, 18 Oct 2020 16:00:45 -0700
Subject: [PATCH 3/7] Move rotate_child_position to
 phoc_utils_rotate_child_position

This generic function seems more appropriate in utils than in 'output'
---
 src/cursor.c  |  8 +++++---
 src/desktop.c |  5 +++--
 src/output.c  | 34 +++++++---------------------------
 src/output.h  |  3 ---
 src/utils.c   | 23 +++++++++++++++++++++++
 src/utils.h   |  2 ++
 6 files changed, 40 insertions(+), 35 deletions(-)

diff --git a/src/cursor.c b/src/cursor.c
index b6cb221..0e2ba7d 100644
--- a/src/cursor.c
+++ b/src/cursor.c
@@ -14,6 +14,7 @@
 #include <linux/input-event-codes.h>
 #include "cursor.h"
 #include "desktop.h"
+#include "utils.h"
 #include "view.h"
 #include "xcursor.h"
 
@@ -594,7 +595,8 @@ void roots_cursor_handle_touch_motion(struct roots_cursor *cursor,
 				scale = view->scale;
 				sx = lx / scale - view->box.x;
 				sy = ly / scale - view->box.y;
-				rotate_child_position(&sx, &sy, 0, 0, view->box.width, view->box.height, -view->rotation);
+				phoc_utils_rotate_child_position(&sx, &sy, 0, 0, view->box.width,
+					view->box.height, -view->rotation);
 				found = true;
 			} else {
 				// FIXME: buggy fallback, but at least handles xdg_popups for now...
@@ -772,8 +774,8 @@ void roots_cursor_constrain(struct roots_cursor *cursor,
 			double box_sx = (boxes[0].x1 + boxes[0].x2) / 2.;
 			double box_sy = (boxes[0].y1 + boxes[0].y2) / 2.;
 
-			rotate_child_position(&box_sx, &box_sy, 0, 0, view->box.width, view->box.height,
-				view->rotation);
+			phoc_utils_rotate_child_position(&box_sx, &box_sy, 0, 0, view->box.width,
+				view->box.height, view->rotation);
 
 			double lx = view->box.x + box_sx;
 			double ly = view->box.y + box_sy;
diff --git a/src/desktop.c b/src/desktop.c
index cc398d9..7f6203f 100644
--- a/src/desktop.c
+++ b/src/desktop.c
@@ -33,6 +33,7 @@
 #include "layers.h"
 #include "seat.h"
 #include "server.h"
+#include "utils.h"
 #include "view.h"
 #include "virtual.h"
 #include "xcursor.h"
@@ -95,7 +96,7 @@ static bool view_at(struct roots_view *view, double lx, double ly,
 
 	double view_sx = lx - (view->box.x * view->scale);
 	double view_sy = ly - (view->box.y * view->scale);
-	rotate_child_position(&view_sx, &view_sy, 0, 0,
+	phoc_utils_rotate_child_position(&view_sx, &view_sy, 0, 0,
 		view->box.width, view->box.height, -view->rotation);
 	view_sx /= view->scale;
 	view_sy /= view->scale;
@@ -338,7 +339,7 @@ static void handle_constraint_destroy(struct wl_listener *listener,
 			double sy = wlr_constraint->current.cursor_hint.y;
 
 			struct roots_view *view = cursor->pointer_view->view;
-			rotate_child_position(&sx, &sy, 0, 0, view->box.width, view->box.height,
+			phoc_utils_rotate_child_position(&sx, &sy, 0, 0, view->box.width, view->box.height,
 				view->rotation);
 			double lx = view->box.x + sx;
 			double ly = view->box.y + sy;
diff --git a/src/output.c b/src/output.c
index a071641..6acf154 100644
--- a/src/output.c
+++ b/src/output.c
@@ -20,29 +20,8 @@
 #include "output.h"
 #include "render.h"
 #include "server.h"
+#include "utils.h"
 
-/**
- * Rotate a child's position relative to a parent. The parent size is (pw, ph),
- * the child position is (*sx, *sy) and its size is (sw, sh).
- */
-void
-rotate_child_position (double *sx, double *sy, double sw, double sh,
-                       double pw, double ph, float rotation)
-{
-  if (rotation == 0.0) {
-    return;
-  }
-
-  // Coordinates relative to the center of the subsurface
-  double cx = *sx - pw/2 + sw/2,
-         cy = *sy - ph/2 + sh/2;
-  // Rotated coordinates
-  double rx = cos (rotation)*cx - sin (rotation)*cy,
-         ry = cos (rotation)*cy + sin (rotation)*cx;
-
-  *sx = rx + pw/2 - sw/2;
-  *sy = ry + ph/2 - sh/2;
-}
 
 struct surface_iterator_data {
   roots_surface_iterator_func_t user_iterator;
@@ -71,8 +50,8 @@ get_surface_box (struct surface_iterator_data *data,
   double _sx = sx + surface->sx;
   double _sy = sy + surface->sy;
 
-  rotate_child_position (&_sx, &_sy, sw, sh, data->width, data->height,
-                         data->rotation);
+  phoc_utils_rotate_child_position (&_sx, &_sy, sw, sh, data->width,
+                                    data->height, data->rotation);
 
   struct wlr_box box = {
     .x = data->ox + _sx,
@@ -357,9 +336,10 @@ get_decoration_box (struct roots_view *view,
   double sx = deco_box.x - view->box.x;
   double sy = deco_box.y - view->box.y;
 
-  rotate_child_position (&sx, &sy, deco_box.width, deco_box.height,
-                         view->wlr_surface->current.width,
-                         view->wlr_surface->current.height, view->rotation);
+  phoc_utils_rotate_child_position (&sx, &sy, deco_box.width, deco_box.height,
+                                    view->wlr_surface->current.width,
+                                    view->wlr_surface->current.height,
+                                    view->rotation);
   double x = sx + view->box.x;
   double y = sy + view->box.y;
 
diff --git a/src/output.h b/src/output.h
index 3b5e53a..ba174dc 100644
--- a/src/output.h
+++ b/src/output.h
@@ -36,9 +36,6 @@ typedef void (*roots_surface_iterator_func_t)(struct roots_output *output,
                                               struct wlr_surface *surface, struct wlr_box *box, float rotation,
                                               float scale, void *user_data);
 
-void     rotate_child_position (double *sx, double *sy, double sw, double sh,
-                                double pw, double ph, float rotation);
-
 void     output_surface_for_each_surface (struct roots_output *output,
                                           struct wlr_surface *surface, double ox, double oy,
                                           roots_surface_iterator_func_t iterator, void *user_data);
diff --git a/src/utils.c b/src/utils.c
index 3d63627..eed8fc0 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -32,3 +32,26 @@ phoc_utils_fix_transform (enum wl_output_transform *transform)
   }
 #endif
 }
+
+/**
+ * Rotate a child's position relative to a parent. The parent size is (pw, ph),
+ * the child position is (*sx, *sy) and its size is (sw, sh).
+ */
+void
+phoc_utils_rotate_child_position (double *sx, double *sy, double sw, double sh,
+                                  double pw, double ph, float rotation)
+{
+  if (rotation == 0.0) {
+    return;
+  }
+
+  // Coordinates relative to the center of the subsurface
+  double cx = *sx - pw/2 + sw/2,
+         cy = *sy - ph/2 + sh/2;
+  // Rotated coordinates
+  double rx = cos (rotation)*cx - sin (rotation)*cy,
+         ry = cos (rotation)*cy + sin (rotation)*cx;
+
+  *sx = rx + pw/2 - sw/2;
+  *sy = ry + ph/2 - sh/2;
+}
diff --git a/src/utils.h b/src/utils.h
index 00f1847..714efe0 100644
--- a/src/utils.h
+++ b/src/utils.h
@@ -3,3 +3,5 @@
 #include <wlr/types/wlr_output_layout.h>
 
 void phoc_utils_fix_transform (enum wl_output_transform *transform);
+void phoc_utils_rotate_child_position (double *sx, double *sy, double sw, double sh,
+                                       double pw, double ph, float rotation);
-- 
2.26.2


From e68887f1626a1ce3868698c91dde0cd2acd7ce42 Mon Sep 17 00:00:00 2001
From: Clayton Craft <clayton@craftyguy.net>
Date: Tue, 20 Oct 2020 00:28:49 -0700
Subject: [PATCH 4/7] output: convert roots_output to PhocOutput gobject

---
 src/output.c | 837 +++++++++++++++++++++++++++++----------------------
 src/output.h | 110 ++++---
 2 files changed, 543 insertions(+), 404 deletions(-)

diff --git a/src/output.c b/src/output.c
index 6acf154..74309e1 100644
--- a/src/output.c
+++ b/src/output.c
@@ -23,11 +23,27 @@
 #include "utils.h"
 
 
+G_DEFINE_TYPE (PhocOutput, phoc_output, G_TYPE_OBJECT);
+
+enum {
+  PROP_0,
+  PROP_DESKTOP,
+  PROP_WLR_OUTPUT,
+  PROP_LAST_PROP
+};
+static GParamSpec *props[PROP_LAST_PROP];
+
+enum {
+  OUTPUT_DESTROY,
+  N_SIGNALS
+};
+static guint signals[N_SIGNALS] = { 0 };
+
 struct surface_iterator_data {
   roots_surface_iterator_func_t user_iterator;
   void                         *user_data;
 
-  struct roots_output          *output;
+  PhocOutput                   *output;
   double                        ox, oy;
   int                           width, height;
   float                         rotation, scale;
@@ -38,7 +54,7 @@ get_surface_box (struct surface_iterator_data *data,
                  struct wlr_surface *surface, int sx, int sy,
                  struct wlr_box *surface_box)
 {
-  struct roots_output *output = data->output;
+  PhocOutput *self = data->output;
 
   if (!wlr_surface_has_buffer (surface)) {
     return false;
@@ -70,18 +86,347 @@ get_surface_box (struct surface_iterator_data *data,
 
   struct wlr_box output_box = {0};
 
-  wlr_output_effective_resolution (output->wlr_output,
+  wlr_output_effective_resolution (self->wlr_output,
                                    &output_box.width, &output_box.height);
-  scale_box (&output_box, 1 / data->scale);
+  phoc_output_scale_box (self, &output_box, 1 / data->scale);
 
   struct wlr_box intersection;
 
   return wlr_box_intersection (&intersection, &output_box, &rotated_box);
 }
 
+
+static void
+phoc_output_set_property (GObject      *object,
+                          guint         property_id,
+                          const GValue *value,
+                          GParamSpec   *pspec)
+{
+  PhocOutput *self = PHOC_OUTPUT (object);
+
+  switch (property_id) {
+  case PROP_DESKTOP:
+    self->desktop = g_value_get_pointer (value);
+    g_object_notify_by_pspec (G_OBJECT (self), props[PROP_DESKTOP]);
+    break;
+  case PROP_WLR_OUTPUT:
+    self->wlr_output = g_value_get_pointer (value);
+    g_object_notify_by_pspec (G_OBJECT (self), props[PROP_WLR_OUTPUT]);
+    break;
+  default:
+    G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    break;
+  }
+}
+
+static void
+phoc_output_get_property (GObject    *object,
+                          guint       property_id,
+                          GValue     *value,
+                          GParamSpec *pspec)
+{
+  PhocOutput *self = PHOC_OUTPUT (object);
+
+  switch (property_id) {
+  case PROP_DESKTOP:
+    g_value_set_pointer (value, self->desktop);
+    break;
+  case PROP_WLR_OUTPUT:
+    g_value_set_pointer (value, self->wlr_output);
+    break;
+  default:
+    G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    break;
+  }
+}
+
+static void
+phoc_output_init (PhocOutput *self)
+{
+}
+
+PhocOutput *
+phoc_output_new (PhocDesktop *desktop, struct wlr_output *wlr_output)
+{
+  return g_object_new (PHOC_TYPE_OUTPUT,
+                       "desktop", desktop,
+                       "wlr-output", wlr_output,
+                       NULL);
+}
+
+static void
+update_output_manager_config (PhocDesktop *desktop)
+{
+  struct wlr_output_configuration_v1 *config =
+    wlr_output_configuration_v1_create ();
+
+  PhocOutput *output;
+
+  wl_list_for_each (output, &desktop->outputs, link) {
+    struct wlr_output_configuration_head_v1 *config_head =
+      wlr_output_configuration_head_v1_create (config, output->wlr_output);
+    struct wlr_box *output_box = wlr_output_layout_get_box (
+      output->desktop->layout, output->wlr_output);
+    if (output_box) {
+      config_head->state.x = output_box->x;
+      config_head->state.y = output_box->y;
+    }
+  }
+
+  wlr_output_manager_v1_set_configuration (desktop->output_manager_v1, config);
+}
+
+static void
+phoc_output_handle_destroy (struct wl_listener *listener, void *data)
+{
+  PhocOutput *self = wl_container_of (listener, self, output_destroy);
+
+  update_output_manager_config (self->desktop);
+
+  g_signal_emit (self, signals[OUTPUT_DESTROY], 0);
+}
+
+static void
+phoc_output_handle_enable (struct wl_listener *listener, void *data)
+{
+  PhocOutput *self = wl_container_of (listener, self, enable);
+
+  update_output_manager_config (self->desktop);
+}
+
+static void
+phoc_output_damage_handle_frame (struct wl_listener *listener,
+                                 void               *data)
+{
+  PhocOutput *self = wl_container_of (listener, self, damage_frame);
+
+  output_render (self);
+}
+
+static void
+phoc_output_damage_handle_destroy (struct wl_listener *listener,
+                                   void               *data)
+{
+  PhocOutput *self = wl_container_of (listener, self, damage_destroy);
+
+  g_signal_emit (self, signals[OUTPUT_DESTROY], 0);
+}
+
+static void
+phoc_output_handle_mode (struct wl_listener *listener, void *data)
+{
+  PhocOutput *self = wl_container_of (listener, self, mode);
+
+  arrange_layers (self);
+  update_output_manager_config (self->desktop);
+}
+
+static void
+phoc_output_handle_transform (struct wl_listener *listener, void *data)
+{
+  PhocOutput *self = wl_container_of (listener, self, transform);
+
+  arrange_layers (self);
+}
+
+static void
+phoc_output_set_mode (struct wlr_output *output, struct roots_output_config *oc)
+{
+  int mhz = (int)(oc->mode.refresh_rate * 1000);
+
+  if (wl_list_empty (&output->modes)) {
+    // Output has no mode, try setting a custom one
+    wlr_output_set_custom_mode (output, oc->mode.width,
+                                oc->mode.height, mhz);
+    return;
+  }
+
+  struct wlr_output_mode *mode, *best = NULL;
+
+  wl_list_for_each (mode, &output->modes, link) {
+    if (mode->width == oc->mode.width && mode->height == oc->mode.height) {
+      if (mode->refresh == mhz) {
+        best = mode;
+        break;
+      }
+      best = mode;
+    }
+  }
+  if (!best) {
+    wlr_log (WLR_ERROR, "Configured mode for %s not available",
+             output->name);
+  } else {
+    wlr_log (WLR_DEBUG, "Assigning configured mode to %s",
+             output->name);
+    wlr_output_set_mode (output, best);
+  }
+}
+
+static void
+phoc_output_constructed (GObject *object)
+{
+  PhocOutput *self = PHOC_OUTPUT (object);
+  PhocServer *server = phoc_server_get_default ();
+  PhocInput *input = server->input;
+
+  g_debug ("Initializing roots output");
+  assert (server->desktop);
+
+  struct roots_config *config = self->desktop->config;
+
+  wlr_log (WLR_DEBUG, "Output '%s' added", self->wlr_output->name);
+  wlr_log (WLR_DEBUG, "'%s %s %s' %" PRId32 "mm x %" PRId32 "mm",
+           self->wlr_output->make, self->wlr_output->model,
+           self->wlr_output->serial, self->wlr_output->phys_width,
+           self->wlr_output->phys_height);
+
+  clock_gettime (CLOCK_MONOTONIC, &self->last_frame);
+  self->wlr_output->data = self;
+  wl_list_insert (&self->desktop->outputs, &self->link);
+
+  self->damage = wlr_output_damage_create (self->wlr_output);
+
+  self->debug_touch_points = NULL;
+
+  self->output_destroy.notify = phoc_output_handle_destroy;
+  wl_signal_add (&self->wlr_output->events.destroy, &self->output_destroy);
+  self->enable.notify = phoc_output_handle_enable;
+  wl_signal_add (&self->wlr_output->events.enable, &self->enable);
+  self->mode.notify = phoc_output_handle_mode;
+  wl_signal_add (&self->wlr_output->events.mode, &self->mode);
+  self->transform.notify = phoc_output_handle_transform;
+  wl_signal_add (&self->wlr_output->events.transform, &self->transform);
+
+  self->damage_frame.notify = phoc_output_damage_handle_frame;
+  wl_signal_add (&self->damage->events.frame, &self->damage_frame);
+  self->damage_destroy.notify = phoc_output_damage_handle_destroy;
+  wl_signal_add (&self->damage->events.destroy, &self->damage_destroy);
+
+  size_t len = sizeof(self->layers) / sizeof(self->layers[0]);
+
+  for (size_t i = 0; i < len; ++i) {
+    wl_list_init (&self->layers[i]);
+  }
+
+  struct roots_output_config *output_config =
+    roots_config_get_output (config, self->wlr_output);
+
+  struct wlr_output_mode *preferred_mode =
+    wlr_output_preferred_mode (self->wlr_output);
+
+  if (output_config) {
+    if (output_config->enable) {
+      if (wlr_output_is_drm (self->wlr_output)) {
+        struct roots_output_mode_config *mode_config;
+        wl_list_for_each (mode_config, &output_config->modes, link) {
+          wlr_drm_connector_add_mode (self->wlr_output, &mode_config->info);
+        }
+      } else if (!wl_list_empty (&output_config->modes)) {
+        wlr_log (WLR_ERROR, "Can only add modes for DRM backend");
+      }
+
+      if (output_config->mode.width) {
+        phoc_output_set_mode (self->wlr_output, output_config);
+      } else if (preferred_mode != NULL) {
+        wlr_output_set_mode (self->wlr_output, preferred_mode);
+      }
+
+      wlr_output_set_scale (self->wlr_output, output_config->scale);
+      wlr_output_set_transform (self->wlr_output, output_config->transform);
+      wlr_output_layout_add (self->desktop->layout, self->wlr_output,
+                             output_config->x, output_config->y);
+    } else {
+      wlr_output_enable (self->wlr_output, false);
+    }
+  } else {
+    if (preferred_mode != NULL) {
+      wlr_output_set_mode (self->wlr_output, preferred_mode);
+    }
+    wlr_output_enable (self->wlr_output, true);
+    wlr_output_layout_add_auto (self->desktop->layout, self->wlr_output);
+  }
+  wlr_output_commit (self->wlr_output);
+
+  struct roots_seat *seat;
+
+  wl_list_for_each (seat, &input->seats, link) {
+    roots_seat_configure_cursor (seat);
+    roots_seat_configure_xcursor (seat);
+  }
+
+  arrange_layers (self);
+  phoc_output_damage_whole (self);
+
+  update_output_manager_config (self->desktop);
+
+  G_OBJECT_CLASS (phoc_output_parent_class)->constructed (object);
+
+}
+
+static void
+phoc_output_finalize (GObject *object)
+{
+  PhocOutput *self = PHOC_OUTPUT (object);
+
+  wl_list_remove (&self->link);
+  wl_list_remove (&self->output_destroy.link);
+  wl_list_remove (&self->enable.link);
+  wl_list_remove (&self->mode.link);
+  wl_list_remove (&self->transform.link);
+  wl_list_remove (&self->damage_frame.link);
+  wl_list_remove (&self->damage_destroy.link);
+  g_list_free_full (self->debug_touch_points, g_free);
+
+  size_t len = sizeof (self->layers) / sizeof (self->layers[0]);
+  for (size_t i = 0; i < len; ++i) {
+    wl_list_remove (&self->layers[i]);
+  }
+
+  G_OBJECT_CLASS (phoc_output_parent_class)->finalize (object);
+}
+
+static void
+phoc_output_dispose (GObject *object)
+{
+  G_OBJECT_CLASS (phoc_output_parent_class)->dispose (object);
+}
+
 static void
-output_for_each_surface_iterator (struct wlr_surface *surface,
-                                  int sx, int sy, void *_data)
+phoc_output_class_init (PhocOutputClass *klass)
+{
+  GObjectClass *object_class = (GObjectClass *)klass;
+
+  object_class->set_property = phoc_output_set_property;
+  object_class->get_property = phoc_output_get_property;
+
+  object_class->constructed = phoc_output_constructed;
+  object_class->dispose = phoc_output_dispose;
+  object_class->finalize = phoc_output_finalize;
+
+  props[PROP_DESKTOP] =
+    g_param_spec_pointer (
+      "desktop",
+      "Desktop",
+      "The desktop object",
+      G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_EXPLICIT_NOTIFY);
+  props[PROP_WLR_OUTPUT] =
+    g_param_spec_pointer (
+      "wlr-output",
+      "wlr-output",
+      "The wlroots output object",
+      G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_EXPLICIT_NOTIFY);
+  g_object_class_install_properties (object_class, PROP_LAST_PROP, props);
+
+  signals[OUTPUT_DESTROY] = g_signal_new ("output-destroyed",
+                                          G_TYPE_OBJECT,
+                                          G_SIGNAL_RUN_LAST,
+                                          0, NULL, NULL, NULL, G_TYPE_NONE, 0);
+
+}
+
+static void
+phoc_output_for_each_surface_iterator (struct wlr_surface *surface,
+                                       int sx, int sy, void *_data)
 {
   struct surface_iterator_data *data = _data;
 
@@ -97,14 +442,15 @@ output_for_each_surface_iterator (struct wlr_surface *surface,
 }
 
 void
-output_surface_for_each_surface (struct roots_output *output,
-                                 struct wlr_surface *surface, double ox, double oy,
-                                 roots_surface_iterator_func_t iterator, void *user_data)
+phoc_output_surface_for_each_surface (PhocOutput *self, struct wlr_surface
+                                      *surface, double ox, double oy,
+                                      roots_surface_iterator_func_t iterator,
+                                      void *user_data)
 {
   struct surface_iterator_data data = {
     .user_iterator = iterator,
     .user_data = user_data,
-    .output = output,
+    .output = self,
     .ox = ox,
     .oy = oy,
     .width = surface->current.width,
@@ -114,18 +460,20 @@ output_surface_for_each_surface (struct roots_output *output,
   };
 
   wlr_surface_for_each_surface (surface,
-                                output_for_each_surface_iterator, &data);
+                                phoc_output_for_each_surface_iterator, &data);
 }
 
 void
-output_xdg_surface_for_each_surface (struct roots_output *output,
-                                     struct wlr_xdg_surface *xdg_surface, double ox, double oy,
-                                     roots_surface_iterator_func_t iterator, void *user_data)
+phoc_output_xdg_surface_for_each_surface (PhocOutput *self, struct
+                                          wlr_xdg_surface *xdg_surface, double
+                                          ox, double oy,
+                                          roots_surface_iterator_func_t
+                                          iterator, void *user_data)
 {
   struct surface_iterator_data data = {
     .user_iterator = iterator,
     .user_data = user_data,
-    .output = output,
+    .output = self,
     .ox = ox,
     .oy = oy,
     .width = xdg_surface->surface->current.width,
@@ -135,16 +483,16 @@ output_xdg_surface_for_each_surface (struct roots_output *output,
   };
 
   wlr_xdg_surface_for_each_surface (xdg_surface,
-                                    output_for_each_surface_iterator, &data);
+                                    phoc_output_for_each_surface_iterator, &data);
 }
 
 void
-output_view_for_each_surface (struct roots_output *output,
-                              struct roots_view *view, roots_surface_iterator_func_t iterator,
-                              void *user_data)
+phoc_output_view_for_each_surface (PhocOutput *self, struct roots_view *view,
+                                   roots_surface_iterator_func_t iterator, void
+                                   *user_data)
 {
   struct wlr_box *output_box =
-    wlr_output_layout_get_box (output->desktop->layout, output->wlr_output);
+    wlr_output_layout_get_box (self->desktop->layout, self->wlr_output);
 
   if (!output_box) {
     return;
@@ -153,7 +501,7 @@ output_view_for_each_surface (struct roots_output *output,
   struct surface_iterator_data data = {
     .user_iterator = iterator,
     .user_data = user_data,
-    .output = output,
+    .output = self,
     .ox = view->box.x - output_box->x,
     .oy = view->box.y - output_box->y,
     .width = view->box.width,
@@ -162,17 +510,18 @@ output_view_for_each_surface (struct roots_output *output,
     .scale = view->scale
   };
 
-  view_for_each_surface (view, output_for_each_surface_iterator, &data);
+  view_for_each_surface (view, phoc_output_for_each_surface_iterator, &data);
 }
 
 #ifdef PHOC_XWAYLAND
 void
-output_xwayland_children_for_each_surface (
-  struct roots_output *output, struct wlr_xwayland_surface *surface,
-  roots_surface_iterator_func_t iterator, void *user_data)
+phoc_output_xwayland_children_for_each_surface (PhocOutput *self, struct
+                                                wlr_xwayland_surface *surface,
+                                                roots_surface_iterator_func_t
+                                                iterator, void *user_data)
 {
   struct wlr_box *output_box =
-    wlr_output_layout_get_box (output->desktop->layout, output->wlr_output);
+    wlr_output_layout_get_box (self->desktop->layout, self->wlr_output);
 
   if (!output_box) {
     return;
@@ -184,26 +533,27 @@ output_xwayland_children_for_each_surface (
     if (child->mapped) {
       double ox = child->x - output_box->x;
       double oy = child->y - output_box->y;
-      output_surface_for_each_surface (output, child->surface,
-                                       ox, oy, iterator, user_data);
+      phoc_output_surface_for_each_surface (self, child->surface, ox, oy, iterator,
+                                            user_data);
     }
-    output_xwayland_children_for_each_surface (output, child,
-                                               iterator, user_data);
+    phoc_output_xwayland_children_for_each_surface (self, child,
+                                                    iterator, user_data);
   }
 }
 #endif
 
 static void
-output_layer_handle_surface (struct roots_output *output,
-                             struct roots_layer_surface *layer_surface, roots_surface_iterator_func_t iterator,
-                             void *user_data)
+phoc_output_layer_handle_surface (PhocOutput *self, struct roots_layer_surface *layer_surface,
+                                  roots_surface_iterator_func_t iterator, void
+                                  *user_data)
 {
   struct wlr_layer_surface_v1 *wlr_layer_surface_v1 =
     layer_surface->layer_surface;
 
-  output_surface_for_each_surface (output, wlr_layer_surface_v1->surface,
-                                   layer_surface->geo.x, layer_surface->geo.y, iterator,
-                                   user_data);
+  phoc_output_surface_for_each_surface (self, wlr_layer_surface_v1->surface,
+                                        layer_surface->geo.x,
+                                        layer_surface->geo.y, iterator,
+                                        user_data);
 
   struct wlr_xdg_popup *state;
 
@@ -219,38 +569,39 @@ output_layer_handle_surface (struct roots_output *output,
     popup_sy = layer_surface->geo.y;
     popup_sy += popup->popup->geometry.y - popup->geometry.y;
 
-    output_xdg_surface_for_each_surface (output, popup,
-                                         popup_sx, popup_sy, iterator, user_data);
+    phoc_output_xdg_surface_for_each_surface (self, popup,
+                                              popup_sx, popup_sy, iterator, user_data);
   }
 }
 
 void
-output_layer_for_each_surface (struct roots_output *output,
-                               struct wl_list *layer_surfaces, roots_surface_iterator_func_t iterator,
-                               void *user_data)
+phoc_output_layer_for_each_surface (PhocOutput                   *self,
+                                    struct wl_list               *layer_surfaces,
+                                    roots_surface_iterator_func_t iterator,
+                                    void                         *user_data)
 {
   struct roots_layer_surface *layer_surface;
 
   wl_list_for_each_reverse (layer_surface, layer_surfaces, link)
   {
     if (layer_surface->layer_surface->current.exclusive_zone <= 0) {
-      output_layer_handle_surface (output, layer_surface, iterator, user_data);
+      phoc_output_layer_handle_surface (self, layer_surface, iterator, user_data);
     }
   }
   wl_list_for_each (layer_surface, layer_surfaces, link) {
     if (layer_surface->layer_surface->current.exclusive_zone > 0) {
-      output_layer_handle_surface (output, layer_surface, iterator, user_data);
+      phoc_output_layer_handle_surface (self, layer_surface, iterator, user_data);
     }
   }
 }
 
 void
-output_drag_icons_for_each_surface (struct roots_output *output,
-                                    PhocInput *input, roots_surface_iterator_func_t iterator,
-                                    void *user_data)
+phoc_output_drag_icons_for_each_surface (PhocOutput *self, PhocInput *input,
+                                         roots_surface_iterator_func_t
+                                         iterator, void *user_data)
 {
   struct wlr_box *output_box =
-    wlr_output_layout_get_box (output->desktop->layout, output->wlr_output);
+    wlr_output_layout_get_box (self->desktop->layout, self->wlr_output);
 
   if (!output_box) {
     return;
@@ -266,46 +617,47 @@ output_drag_icons_for_each_surface (struct roots_output *output,
 
     double ox = drag_icon->x - output_box->x;
     double oy = drag_icon->y - output_box->y;
-    output_surface_for_each_surface (output,
-                                     drag_icon->wlr_drag_icon->surface, ox, oy, iterator, user_data);
+    phoc_output_surface_for_each_surface (self, drag_icon->wlr_drag_icon->surface,
+                                          ox, oy, iterator, user_data);
   }
 }
 
 void
-output_for_each_surface (struct roots_output *output,
-                         roots_surface_iterator_func_t iterator, void *user_data)
+phoc_output_for_each_surface (PhocOutput *self, roots_surface_iterator_func_t iterator, void
+                              *user_data)
 {
-  PhocDesktop *desktop = output->desktop;
+  PhocDesktop *desktop = self->desktop;
   PhocServer *server = phoc_server_get_default ();
 
-  if (output->fullscreen_view != NULL) {
-    struct roots_view *view = output->fullscreen_view;
+  if (self->fullscreen_view != NULL) {
+    struct roots_view *view = self->fullscreen_view;
 
-    output_view_for_each_surface (output, view, iterator, user_data);
+    phoc_output_view_for_each_surface (self, view, iterator, user_data);
 
 #ifdef PHOC_XWAYLAND
     if (view->type == ROOTS_XWAYLAND_VIEW) {
       struct roots_xwayland_surface *xwayland_surface =
         roots_xwayland_surface_from_view (view);
-      output_xwayland_children_for_each_surface (output,
-                                                 xwayland_surface->xwayland_surface, iterator, user_data);
+      phoc_output_xwayland_children_for_each_surface (self,
+                                                      xwayland_surface->xwayland_surface,
+                                                      iterator, user_data);
     }
 #endif
   } else {
     struct roots_view *view;
     wl_list_for_each_reverse (view, &desktop->views, link)
     {
-      output_view_for_each_surface (output, view, iterator, user_data);
+      phoc_output_view_for_each_surface (self, view, iterator, user_data);
     }
   }
 
-  output_drag_icons_for_each_surface (output, server->input,
-                                      iterator, user_data);
+  phoc_output_drag_icons_for_each_surface (self, server->input,
+                                           iterator, user_data);
 
-  size_t len = sizeof(output->layers) / sizeof(output->layers[0]);
+  size_t len = sizeof(self->layers) / sizeof(self->layers[0]);
   for (size_t i = 0; i < len; ++i) {
-    output_layer_for_each_surface (output, &output->layers[i],
-                                   iterator, user_data);
+    phoc_output_layer_for_each_surface (self, &self->layers[i],
+                                        iterator, user_data);
   }
 }
 
@@ -316,7 +668,7 @@ scale_length (int length, int offset, float scale)
 }
 
 void
-scale_box (struct wlr_box *box, float scale)
+phoc_output_scale_box (PhocOutput *self, struct wlr_box *box, float scale)
 {
   box->width = scale_length (box->width, box->x, scale);
   box->height = scale_length (box->height, box->y, scale);
@@ -325,11 +677,9 @@ scale_box (struct wlr_box *box, float scale)
 }
 
 void
-get_decoration_box (struct roots_view *view,
-                    struct roots_output *output, struct wlr_box *box)
+phoc_output_get_decoration_box (PhocOutput *self, struct roots_view *view,
+                                struct wlr_box *box)
 {
-  struct wlr_output *wlr_output = output->wlr_output;
-
   struct wlr_box deco_box;
 
   view_get_deco_box (view, &deco_box);
@@ -343,41 +693,41 @@ get_decoration_box (struct roots_view *view,
   double x = sx + view->box.x;
   double y = sy + view->box.y;
 
-  wlr_output_layout_output_coords (output->desktop->layout, wlr_output, &x, &y);
+  wlr_output_layout_output_coords (self->desktop->layout,
+                                   self->wlr_output, &x, &y);
 
-  box->x = x * wlr_output->scale;
-  box->y = y * wlr_output->scale;
-  box->width = deco_box.width * wlr_output->scale;
-  box->height = deco_box.height * wlr_output->scale;
+  box->x = x * self->wlr_output->scale;
+  box->y = y * self->wlr_output->scale;
+  box->width = deco_box.width * self->wlr_output->scale;
+  box->height = deco_box.height * self->wlr_output->scale;
 }
 
 void
-output_damage_whole (struct roots_output *output)
+phoc_output_damage_whole (PhocOutput *self)
 {
-  wlr_output_damage_add_whole (output->damage);
+  wlr_output_damage_add_whole (self->damage);
 }
 
 static bool
-view_accept_damage (struct roots_output *output,
-                    struct roots_view   *view)
+phoc_view_accept_damage (PhocOutput *self, struct roots_view   *view)
 {
   if (view->wlr_surface == NULL) {
     return false;
   }
-  if (output->fullscreen_view == NULL) {
+  if (self->fullscreen_view == NULL) {
     return true;
   }
-  if (output->fullscreen_view == view) {
+  if (self->fullscreen_view == view) {
     return true;
   }
 #ifdef PHOC_XWAYLAND
-  if (output->fullscreen_view->type == ROOTS_XWAYLAND_VIEW &&
+  if (self->fullscreen_view->type == ROOTS_XWAYLAND_VIEW &&
       view->type == ROOTS_XWAYLAND_VIEW) {
     // Special case: accept damage from children
     struct wlr_xwayland_surface *xsurface =
       roots_xwayland_surface_from_view (view)->xwayland_surface;
     struct wlr_xwayland_surface *fullscreen_xsurface =
-      roots_xwayland_surface_from_view (output->fullscreen_view)->xwayland_surface;
+      roots_xwayland_surface_from_view (self->fullscreen_view)->xwayland_surface;
     while (xsurface != NULL) {
       if (fullscreen_xsurface == xsurface) {
         return true;
@@ -390,16 +740,15 @@ view_accept_damage (struct roots_output *output,
 }
 
 static void
-damage_surface_iterator (struct roots_output *output,
-                         struct wlr_surface *surface, struct wlr_box *_box, float rotation,
-                         float scale, void *data)
+damage_surface_iterator (PhocOutput *self, struct wlr_surface *surface, struct
+                         wlr_box *_box, float rotation, float scale, void *data)
 {
   bool *whole = data;
 
   struct wlr_box box = *_box;
 
-  scale_box (&box, scale);
-  scale_box (&box, output->wlr_output->scale);
+  phoc_output_scale_box (self, &box, scale);
+  phoc_output_scale_box (self, &box, self->wlr_output->scale);
 
   int center_x = box.x + box.width/2;
   int center_y = box.y + box.height/2;
@@ -409,41 +758,40 @@ damage_surface_iterator (struct roots_output *output,
     pixman_region32_init (&damage);
     wlr_surface_get_effective_damage (surface, &damage);
     wlr_region_scale (&damage, &damage, scale);
-    wlr_region_scale (&damage, &damage, output->wlr_output->scale);
-    if (ceil (output->wlr_output->scale) > surface->current.scale) {
+    wlr_region_scale (&damage, &damage, self->wlr_output->scale);
+    if (ceil (self->wlr_output->scale) > surface->current.scale) {
       // When scaling up a surface, it'll become blurry so we need to
       // expand the damage region
       wlr_region_expand (&damage, &damage,
-                         ceil (output->wlr_output->scale) - surface->current.scale);
+                         ceil (self->wlr_output->scale) - surface->current.scale);
     }
     pixman_region32_translate (&damage, box.x, box.y);
     wlr_region_rotated_bounds (&damage, &damage, rotation,
                                center_x, center_y);
-    wlr_output_damage_add (output->damage, &damage);
+    wlr_output_damage_add (self->damage, &damage);
     pixman_region32_fini (&damage);
   }
 
   if (*whole) {
     wlr_box_rotated_bounds (&box, &box, rotation);
-    wlr_output_damage_add_box (output->damage, &box);
+    wlr_output_damage_add_box (self->damage, &box);
   }
 
-  wlr_output_schedule_frame (output->wlr_output);
+  wlr_output_schedule_frame (self->wlr_output);
 }
 
 void
-output_damage_whole_local_surface (struct roots_output *output,
-                                   struct wlr_surface *surface, double ox, double oy)
+phoc_output_damage_whole_local_surface (PhocOutput *self, struct wlr_surface *surface, double ox,
+                                        double oy)
 {
   bool whole = true;
 
-  output_surface_for_each_surface (output, surface, ox, oy,
-                                   damage_surface_iterator, &whole);
+  phoc_output_surface_for_each_surface (self, surface, ox, oy,
+                                        damage_surface_iterator, &whole);
 }
 
 static void
-damage_whole_decoration (struct roots_view   *view,
-                         struct roots_output *output)
+damage_whole_decoration (PhocOutput *self, struct roots_view   *view)
 {
   if (!view->decorated || view->wlr_surface == NULL) {
     return;
@@ -451,112 +799,60 @@ damage_whole_decoration (struct roots_view   *view,
 
   struct wlr_box box;
 
-  get_decoration_box (view, output, &box);
+  phoc_output_get_decoration_box (self, view, &box);
 
   wlr_box_rotated_bounds (&box, &box, view->rotation);
 
-  wlr_output_damage_add_box (output->damage, &box);
+  wlr_output_damage_add_box (self->damage, &box);
 }
 
 void
-output_damage_whole_view (struct roots_output *output,
-                          struct roots_view   *view)
+phoc_output_damage_whole_view (PhocOutput *self, struct roots_view   *view)
 {
-  if (!view_accept_damage (output, view)) {
+  if (!phoc_view_accept_damage (self, view)) {
     return;
   }
 
-  damage_whole_decoration (view, output);
+  damage_whole_decoration (self, view);
 
   bool whole = true;
 
-  output_view_for_each_surface (output, view, damage_surface_iterator, &whole);
+  phoc_output_view_for_each_surface (self, view, damage_surface_iterator, &whole);
 }
 
-void
-output_damage_whole_drag_icon (struct roots_output    *output,
-                               struct roots_drag_icon *icon)
-{
-  bool whole = true;
-
-  output_surface_for_each_surface (output, icon->wlr_drag_icon->surface,
-                                   icon->x, icon->y, damage_surface_iterator, &whole);
-}
-
-void
-output_damage_from_local_surface (struct roots_output *output,
-                                  struct wlr_surface *surface, double ox, double oy)
-{
-  bool whole = false;
-
-  output_surface_for_each_surface (output, surface, ox, oy,
-                                   damage_surface_iterator, &whole);
-}
 
 void
-output_damage_from_view (struct roots_output *output,
-                         struct roots_view   *view)
+phoc_output_damage_from_view (PhocOutput *self, struct roots_view *view)
 {
-  if (!view_accept_damage (output, view)) {
+  if (!phoc_view_accept_damage (self, view)) {
     return;
   }
 
   bool whole = false;
 
-  output_view_for_each_surface (output, view, damage_surface_iterator, &whole);
+  phoc_output_view_for_each_surface (self, view, damage_surface_iterator, &whole);
+
 }
 
-static void
-set_mode (struct wlr_output          *output,
-          struct roots_output_config *oc)
+void
+phoc_output_damage_whole_drag_icon (PhocOutput *self, struct roots_drag_icon
+                                    *icon)
 {
-  int mhz = (int)(oc->mode.refresh_rate * 1000);
-
-  if (wl_list_empty (&output->modes)) {
-    // Output has no mode, try setting a custom one
-    wlr_output_set_custom_mode (output, oc->mode.width, oc->mode.height, mhz);
-    return;
-  }
-
-  struct wlr_output_mode *mode, *best = NULL;
+  bool whole = true;
 
-  wl_list_for_each (mode, &output->modes, link) {
-    if (mode->width == oc->mode.width && mode->height == oc->mode.height) {
-      if (mode->refresh == mhz) {
-        best = mode;
-        break;
-      }
-      best = mode;
-    }
-  }
-  if (!best) {
-    wlr_log (WLR_ERROR, "Configured mode for %s not available", output->name);
-  } else {
-    wlr_log (WLR_DEBUG, "Assigning configured mode to %s", output->name);
-    wlr_output_set_mode (output, best);
-  }
+  phoc_output_surface_for_each_surface (self, icon->wlr_drag_icon->surface,
+                                        icon->x, icon->y,
+                                        damage_surface_iterator, &whole);
 }
 
-static void
-update_output_manager_config (PhocDesktop *desktop)
+void
+phoc_output_damage_from_local_surface (PhocOutput *self, struct wlr_surface
+                                       *surface, double ox, double oy)
 {
-  struct wlr_output_configuration_v1 *config =
-    wlr_output_configuration_v1_create ();
-
-  struct roots_output *output;
-
-  wl_list_for_each (output, &desktop->outputs, link) {
-    struct wlr_output_configuration_head_v1 *config_head =
-      wlr_output_configuration_head_v1_create (config, output->wlr_output);
-    struct wlr_box *output_box = wlr_output_layout_get_box (
-      output->desktop->layout, output->wlr_output);
-    if (output_box) {
-      config_head->state.x = output_box->x;
-      config_head->state.y = output_box->y;
-    }
-  }
+  bool whole = false;
 
-  wlr_output_manager_v1_set_configuration (desktop->output_manager_v1, config);
+  phoc_output_surface_for_each_surface (self, surface, ox, oy,
+                                        damage_surface_iterator, &whole);
 }
 
 void
@@ -633,11 +929,10 @@ void
 phoc_output_handle_output_power_manager_set_mode (struct wl_listener *listener, void *data)
 {
   struct wlr_output_power_v1_set_mode_event *event = data;
-  struct roots_output *self;
+  PhocOutput *self;
   bool enable = true;
 
   g_return_if_fail (event && event->output && event->output->data);
-
   self = event->output->data;
   g_debug ("Request to set output power mode of %p to %d",
            self, event->mode);
@@ -663,180 +958,7 @@ phoc_output_handle_output_power_manager_set_mode (struct wl_listener *listener,
   }
 
   if (enable)
-    output_damage_whole (self);
-}
-
-static void
-output_destroy (struct roots_output *output)
-{
-  // TODO: cursor
-  // example_config_configure_cursor(sample->config, sample->cursor,
-  //	sample->compositor);
-
-  wl_list_remove (&output->link);
-  wl_list_remove (&output->destroy.link);
-  wl_list_remove (&output->enable.link);
-  wl_list_remove (&output->mode.link);
-  wl_list_remove (&output->transform.link);
-  wl_list_remove (&output->damage_frame.link);
-  wl_list_remove (&output->damage_destroy.link);
-  free (output);
-}
-
-static void
-output_handle_destroy (struct wl_listener *listener, void *data)
-{
-  struct roots_output *output = wl_container_of (listener, output, destroy);
-  PhocDesktop *desktop = output->desktop;
-
-  output_destroy (output);
-  update_output_manager_config (desktop);
-}
-
-static void
-output_handle_enable (struct wl_listener *listener, void *data)
-{
-  struct roots_output *output = wl_container_of (listener, output, enable);
-
-  update_output_manager_config (output->desktop);
-}
-
-static void
-output_damage_handle_frame (struct wl_listener *listener,
-                            void               *data)
-{
-  struct roots_output *output =
-    wl_container_of (listener, output, damage_frame);
-
-  output_render (output);
-}
-
-static void
-output_damage_handle_destroy (struct wl_listener *listener,
-                              void               *data)
-{
-  struct roots_output *output =
-    wl_container_of (listener, output, damage_destroy);
-
-  output_destroy (output);
-}
-
-static void
-output_handle_mode (struct wl_listener *listener, void *data)
-{
-  struct roots_output *output =
-    wl_container_of (listener, output, mode);
-
-  arrange_layers (output);
-  update_output_manager_config (output->desktop);
-}
-
-static void
-output_handle_transform (struct wl_listener *listener, void *data)
-{
-  struct roots_output *output =
-    wl_container_of (listener, output, transform);
-
-  arrange_layers (output);
-}
-
-void
-handle_new_output (struct wl_listener *listener, void *data)
-{
-  PhocDesktop *desktop = wl_container_of (listener, desktop,
-                                          new_output);
-  struct wlr_output *wlr_output = data;
-  PhocServer *server = phoc_server_get_default ();
-  PhocInput *input = server->input;
-  struct roots_config *config = desktop->config;
-
-  wlr_log (WLR_DEBUG, "Output '%s' added", wlr_output->name);
-  wlr_log (WLR_DEBUG, "'%s %s %s' %" PRId32 "mm x %" PRId32 "mm", wlr_output->make,
-           wlr_output->model, wlr_output->serial, wlr_output->phys_width,
-           wlr_output->phys_height);
-
-  struct roots_output *output = calloc (1, sizeof(struct roots_output));
-
-  clock_gettime (CLOCK_MONOTONIC, &output->last_frame);
-  output->desktop = desktop;
-  output->wlr_output = wlr_output;
-  wlr_output->data = output;
-  wl_list_insert (&desktop->outputs, &output->link);
-
-  output->damage = wlr_output_damage_create (wlr_output);
-
-  output->debug_touch_points = NULL;
-
-  output->destroy.notify = output_handle_destroy;
-  wl_signal_add (&wlr_output->events.destroy, &output->destroy);
-  output->enable.notify = output_handle_enable;
-  wl_signal_add (&wlr_output->events.enable, &output->enable);
-  output->mode.notify = output_handle_mode;
-  wl_signal_add (&wlr_output->events.mode, &output->mode);
-  output->transform.notify = output_handle_transform;
-  wl_signal_add (&wlr_output->events.transform, &output->transform);
-
-  output->damage_frame.notify = output_damage_handle_frame;
-  wl_signal_add (&output->damage->events.frame, &output->damage_frame);
-  output->damage_destroy.notify = output_damage_handle_destroy;
-  wl_signal_add (&output->damage->events.destroy, &output->damage_destroy);
-
-  size_t len = sizeof(output->layers) / sizeof(output->layers[0]);
-
-  for (size_t i = 0; i < len; ++i) {
-    wl_list_init (&output->layers[i]);
-  }
-
-  struct roots_output_config *output_config =
-    roots_config_get_output (config, wlr_output);
-
-  struct wlr_output_mode *preferred_mode =
-    wlr_output_preferred_mode (wlr_output);
-
-  if (output_config) {
-    if (output_config->enable) {
-      if (wlr_output_is_drm (wlr_output)) {
-        struct roots_output_mode_config *mode_config;
-        wl_list_for_each (mode_config, &output_config->modes, link) {
-          wlr_drm_connector_add_mode (wlr_output, &mode_config->info);
-        }
-      } else if (!wl_list_empty (&output_config->modes)) {
-        wlr_log (WLR_ERROR, "Can only add modes for DRM backend");
-      }
-
-      if (output_config->mode.width) {
-        set_mode (wlr_output, output_config);
-      } else if (preferred_mode != NULL) {
-        wlr_output_set_mode (wlr_output, preferred_mode);
-      }
-
-      wlr_output_set_scale (wlr_output, output_config->scale);
-      wlr_output_set_transform (wlr_output, output_config->transform);
-      wlr_output_layout_add (desktop->layout, wlr_output, output_config->x,
-                             output_config->y);
-    } else {
-      wlr_output_enable (wlr_output, false);
-    }
-  } else {
-    if (preferred_mode != NULL) {
-      wlr_output_set_mode (wlr_output, preferred_mode);
-    }
-    wlr_output_enable (wlr_output, true);
-    wlr_output_layout_add_auto (desktop->layout, wlr_output);
-  }
-  wlr_output_commit (wlr_output);
-
-  struct roots_seat *seat;
-
-  wl_list_for_each (seat, &input->seats, link) {
-    roots_seat_configure_cursor (seat);
-    roots_seat_configure_xcursor (seat);
-  }
-
-  arrange_layers (output);
-  output_damage_whole (output);
-
-  update_output_manager_config (desktop);
+    phoc_output_damage_whole (self);
 }
 
 /**
@@ -846,20 +968,17 @@ handle_new_output (struct wl_listener *listener, void *data)
  * phone LCD), %FALSE otherwise.
  */
 gboolean
-phoc_output_is_builtin (struct roots_output *self)
+phoc_output_is_builtin (PhocOutput *output)
 {
-  struct wlr_output *output;
-
-  g_return_val_if_fail (self, FALSE);
-  g_return_val_if_fail (self->wlr_output, FALSE);
-  output = self->wlr_output;
-  g_return_val_if_fail (output->name, FALSE);
+  g_return_val_if_fail (output, FALSE);
+  g_return_val_if_fail (output->wlr_output, FALSE);
+  g_return_val_if_fail (output->wlr_output->name, FALSE);
 
-  if (g_str_has_prefix (output->name, "LVDS-"))
+  if (g_str_has_prefix (output->wlr_output->name, "LVDS-"))
     return TRUE;
-  else if (g_str_has_prefix (output->name, "eDP-"))
+  else if (g_str_has_prefix (output->wlr_output->name, "eDP-"))
     return TRUE;
-  else if (g_str_has_prefix (output->name, "DSI-"))
+  else if (g_str_has_prefix (output->wlr_output->name, "DSI-"))
     return TRUE;
 
   return FALSE;
diff --git a/src/output.h b/src/output.h
index ba174dc..7f049a6 100644
--- a/src/output.h
+++ b/src/output.h
@@ -1,18 +1,31 @@
 #ifndef ROOTSTON_OUTPUT_H
 #define ROOTSTON_OUTPUT_H
 
-#include "desktop.h"
-
+#include <gio/gio.h>
+#include <glib-object.h>
 #include <pixman.h>
 #include <time.h>
 #include <wayland-server-core.h>
 #include <wlr/types/wlr_box.h>
 #include <wlr/types/wlr_output_damage.h>
 
-struct roots_output {
+#define PHOC_TYPE_OUTPUT (phoc_output_get_type ())
+
+G_DECLARE_FINAL_TYPE (PhocOutput, phoc_output, PHOC, OUTPUT, GObject);
+
+/* These need to know about PhocOutput so we have them after the type definition.
+ * This will fix itself once view / phosh are gobjects and most of
+ * their members are non-public. */
+#include "desktop.h"
+
+/* TODO: we keep the struct public due to the list links and
+   notifiers but we should avoid other member access */
+struct _PhocOutput {
+  GObject                   parent;
+
   PhocDesktop              *desktop;
   struct wlr_output        *wlr_output;
-  struct wl_list            link; // roots_desktop:outputs
+  struct wl_list            link; // PhocDesktop::outputs
 
   struct roots_view        *fullscreen_view;
   struct wl_list            layers[4]; // layer_surface::link
@@ -24,65 +37,72 @@ struct roots_output {
 
   struct wlr_box            usable_area;
 
-  struct wl_listener        destroy;
   struct wl_listener        enable;
   struct wl_listener        mode;
   struct wl_listener        transform;
   struct wl_listener        damage_frame;
   struct wl_listener        damage_destroy;
+  struct wl_listener        output_destroy;
 };
 
-typedef void (*roots_surface_iterator_func_t)(struct roots_output *output,
+PhocOutput *phoc_output_new (PhocDesktop       *desktop,
+                             struct wlr_output *wlr_output);
+
+typedef void (*roots_surface_iterator_func_t)(PhocOutput *self,
                                               struct wlr_surface *surface, struct wlr_box *box, float rotation,
                                               float scale, void *user_data);
 
-void     output_surface_for_each_surface (struct roots_output *output,
-                                          struct wlr_surface *surface, double ox, double oy,
-                                          roots_surface_iterator_func_t iterator, void *user_data);
-void     output_xdg_surface_for_each_surface (struct roots_output *output,
-                                              struct wlr_xdg_surface *xdg_surface, double ox, double oy,
-                                              roots_surface_iterator_func_t iterator, void *user_data);
-void     output_view_for_each_surface (struct roots_output *output,
-                                       struct roots_view *view, roots_surface_iterator_func_t iterator,
-                                       void *user_data);
-void     output_drag_icons_for_each_surface (struct roots_output *output,
-                                             PhocInput *input, roots_surface_iterator_func_t iterator,
-                                             void *user_data);
-void     output_layer_for_each_surface (struct roots_output *output,
-                                        struct wl_list *layer_surfaces, roots_surface_iterator_func_t iterator,
-                                        void *user_data);
+void        phoc_output_xdg_surface_for_each_surface (
+  PhocOutput *self,
+  struct wlr_xdg_surface *xdg_surface, double ox, double oy,
+  roots_surface_iterator_func_t iterator, void *user_data);
+void        phoc_output_surface_for_each_surface (PhocOutput *self, struct wlr_surface
+                                                  *surface, double ox, double oy,
+                                                  roots_surface_iterator_func_t iterator,
+                                                  void *user_data);
+void        phoc_output_view_for_each_surface (
+  PhocOutput *self,
+  struct roots_view *view, roots_surface_iterator_func_t iterator,
+  void *user_data);
+void        phoc_output_drag_icons_for_each_surface (
+  PhocOutput *self,
+  PhocInput *input, roots_surface_iterator_func_t iterator,
+  void *user_data);
+void        phoc_output_layer_for_each_surface (
+  PhocOutput *self,
+  struct wl_list *layer_surfaces, roots_surface_iterator_func_t iterator,
+  void *user_data);
 #ifdef PHOC_XWAYLAND
 struct wlr_xwayland_surface;
-void     output_xwayland_children_for_each_surface (
-  struct roots_output *output, struct wlr_xwayland_surface *surface,
+void        phoc_output_xwayland_children_for_each_surface (
+  PhocOutput *self,
+  struct wlr_xwayland_surface *surface,
   roots_surface_iterator_func_t iterator, void *user_data);
 #endif
-void     output_for_each_surface (struct roots_output *output,
-                                  roots_surface_iterator_func_t iterator, void *user_data);
+void        phoc_output_for_each_surface (PhocOutput                   *self,
+                                          roots_surface_iterator_func_t iterator,
+                                          void                         *user_data);
 
-void     handle_new_output (struct wl_listener *listener, void *data);
-void     handle_output_manager_apply (struct wl_listener *listener, void *data);
-void     handle_output_manager_test (struct wl_listener *listener, void *data);
-void     phoc_output_handle_output_power_manager_set_mode (struct wl_listener *listener, void *data);
+void        handle_output_manager_apply (struct wl_listener *listener, void *data);
+void        handle_output_manager_test (struct wl_listener *listener, void *data);
+void        phoc_output_handle_output_power_manager_set_mode (struct wl_listener *listener, void *data);
 
 struct roots_view;
 struct roots_drag_icon;
+void        phoc_output_damage_whole (PhocOutput *output);
+void        phoc_output_damage_whole_view (PhocOutput *self, struct roots_view   *view);
+void        phoc_output_damage_from_view (PhocOutput *self, struct roots_view
+                                          *view);
+void        phoc_output_damage_whole_drag_icon (PhocOutput             *self,
+                                                struct roots_drag_icon *icon);
+void        phoc_output_damage_from_local_surface (PhocOutput *self, struct wlr_surface *surface, double
+                                                   ox, double oy);
+void        phoc_output_damage_whole_local_surface (PhocOutput *self, struct wlr_surface *surface,
+                                                    double ox, double oy);
 
-void     output_damage_whole (struct roots_output *output);
-void     output_damage_whole_view (struct roots_output *output,
-                                   struct roots_view   *view);
-void     output_damage_from_view (struct roots_output *output,
-                                  struct roots_view   *view);
-void     output_damage_whole_drag_icon (struct roots_output    *output,
-                                        struct roots_drag_icon *icon);
-void     output_damage_from_local_surface (struct roots_output *output,
-                                           struct wlr_surface *surface, double ox, double oy);
-void     output_damage_whole_local_surface (struct roots_output *output,
-                                            struct wlr_surface *surface, double ox, double oy);
-
-void     scale_box (struct wlr_box *box, float scale);
-void     get_decoration_box (struct roots_view *view,
-                             struct roots_output *output, struct wlr_box *box);
-gboolean phoc_output_is_builtin (struct roots_output *self);
+void        phoc_output_scale_box (PhocOutput *self, struct wlr_box *box, float scale);
+void        phoc_output_get_decoration_box (PhocOutput *self, struct roots_view *view,
+                                            struct wlr_box *box);
+gboolean    phoc_output_is_builtin (PhocOutput *output);
 
 #endif
-- 
2.26.2


From 89755ddb5897769dfcc0a9a0a30d4e05af71b794 Mon Sep 17 00:00:00 2001
From: Clayton Craft <clayton@craftyguy.net>
Date: Fri, 13 Nov 2020 23:32:39 -0800
Subject: [PATCH 5/7] desktop: add handler for new output

---
 src/desktop.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/desktop.c b/src/desktop.c
index 7f6203f..53b7297 100644
--- a/src/desktop.c
+++ b/src/desktop.c
@@ -445,6 +445,13 @@ void handle_xwayland_ready(struct wl_listener *listener, void *data) {
 }
 #endif
 
+static void
+handle_new_output (struct wl_listener *listener, void *data)
+{
+	PhocDesktop *self = wl_container_of (listener, self, new_output);
+	PhocOutput *output = phoc_output_new (self, (struct wlr_output *)data);
+}
+
 static void
 phoc_desktop_constructed (GObject *object)
 {
-- 
2.26.2


From 7a1e38f8c0f2c33213556034325f1cafb699f28b Mon Sep 17 00:00:00 2001
From: Clayton Craft <clayton@craftyguy.net>
Date: Sat, 14 Nov 2020 19:17:43 -0800
Subject: [PATCH 6/7] desktop: add handler for output destroy

---
 src/desktop.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/src/desktop.c b/src/desktop.c
index 53b7297..43b3c6f 100644
--- a/src/desktop.c
+++ b/src/desktop.c
@@ -445,11 +445,21 @@ void handle_xwayland_ready(struct wl_listener *listener, void *data) {
 }
 #endif
 
+static void
+handle_output_destroy (PhocOutput *destroyed_output)
+{
+	g_object_unref (destroyed_output);
+}
+
 static void
 handle_new_output (struct wl_listener *listener, void *data)
 {
 	PhocDesktop *self = wl_container_of (listener, self, new_output);
 	PhocOutput *output = phoc_output_new (self, (struct wlr_output *)data);
+
+	g_signal_connect (output, "output-destroyed",
+			  G_CALLBACK (handle_output_destroy),
+			  NULL);
 }
 
 static void
-- 
2.26.2


From cdbe3aeee35497847d0710f8bff420e5a7028d6c Mon Sep 17 00:00:00 2001
From: Clayton Craft <clayton@craftyguy.net>
Date: Fri, 13 Nov 2020 23:22:21 -0800
Subject: [PATCH 7/7] Use PhocOutput instead of roots_output

---
 src/cursor.c      | 14 ++++++-------
 src/desktop.c     | 45 +++++++++++++++++++---------------------
 src/desktop.h     |  2 +-
 src/layer_shell.c | 48 +++++++++++++++++++++----------------------
 src/layers.h      |  5 ++---
 src/render.c      | 46 ++++++++++++++++++++---------------------
 src/render.h      |  2 +-
 src/seat.c        | 14 ++++++-------
 src/view.c        | 52 +++++++++++++++++++++++------------------------
 src/view.h        |  4 +++-
 10 files changed, 115 insertions(+), 117 deletions(-)

diff --git a/src/cursor.c b/src/cursor.c
index 0e2ba7d..87a97fa 100644
--- a/src/cursor.c
+++ b/src/cursor.c
@@ -125,7 +125,7 @@ static bool roots_handle_shell_reveal(struct wlr_surface *surface, double lx, do
 	}
 
 	struct wlr_output *wlr_output = wlr_output_layout_output_at(desktop->layout, lx, ly);
-	struct roots_output *output = wlr_output->data;
+	PhocOutput *output = wlr_output->data;
 	if (!output) {
 		return false;
 	}
@@ -163,13 +163,13 @@ static bool roots_handle_shell_reveal(struct wlr_surface *surface, double lx, do
 			(right  && lx >= output_box->x + (1.0 - threshold) * output_box->width - 1)) {
 		if (output->fullscreen_view && output->fullscreen_view->wlr_surface == root) {
 			output->force_shell_reveal = true;
-			output_damage_whole(output);
+			phoc_output_damage_whole(output);
 		}
 		return true;
 	} else {
 		if (output->force_shell_reveal) {
 			output->force_shell_reveal = false;
-			output_damage_whole(output);
+			phoc_output_damage_whole(output);
 		}
 	}
 
@@ -510,7 +510,7 @@ void roots_cursor_handle_touch_down(struct roots_cursor *cursor,
 	}
 
 	if (server->debug_flags & PHOC_SERVER_DEBUG_FLAG_TOUCH_POINTS) {
-		struct roots_output *output;
+		PhocOutput *output;
 		wl_list_for_each(output, &desktop->outputs, link) {
 			if (wlr_output_layout_contains_point(desktop->layout, output->wlr_output, lx, ly)) {
 				double ox = lx, oy = ly;
@@ -557,7 +557,7 @@ void roots_cursor_handle_touch_motion(struct roots_cursor *cursor,
 	if (!wlr_output) {
 		return;
 	}
-	struct roots_output *roots_output = wlr_output->data;
+	PhocOutput *phoc_output = wlr_output->data;
 
 	double sx, sy;
 	struct wlr_surface *surface = point->focus_surface;
@@ -572,7 +572,7 @@ void roots_cursor_handle_touch_motion(struct roots_cursor *cursor,
 		if (wlr_surface_is_layer_surface(root)) {
 			struct wlr_layer_surface_v1 *layer_surface = wlr_layer_surface_v1_from_wlr_surface(root);
 			struct roots_layer_surface *layer;
-			wl_list_for_each_reverse(layer, &roots_output->layers[layer_surface->current.layer], link) {
+			wl_list_for_each_reverse(layer, &phoc_output->layers[layer_surface->current.layer], link) {
 				if (layer->layer_surface->surface == root) {
 					sx = lx - layer->geo.x;
 					sy = ly - layer->geo.y;
@@ -581,7 +581,7 @@ void roots_cursor_handle_touch_motion(struct roots_cursor *cursor,
 				}
 			}
 			// try the overlay layer as well since the on-screen keyboard might have been elevated there
-			wl_list_for_each_reverse(layer, &roots_output->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY], link) {
+			wl_list_for_each_reverse(layer, &phoc_output->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY], link) {
 				if (layer->layer_surface->surface == root) {
 					sx = lx - layer->geo.x;
 					sy = ly - layer->geo.y;
diff --git a/src/desktop.c b/src/desktop.c
index 43b3c6f..b9222ff 100644
--- a/src/desktop.c
+++ b/src/desktop.c
@@ -31,6 +31,7 @@
 #include <wlr/util/log.h>
 #include <wlr/version.h>
 #include "layers.h"
+#include "output.h"
 #include "seat.h"
 #include "server.h"
 #include "utils.h"
@@ -148,8 +149,9 @@ static struct roots_view *desktop_view_at(PhocDesktop *desktop,
 	return NULL;
 }
 
-static struct wlr_surface *layer_surface_at(struct roots_output *output,
-		struct wl_list *layer, double ox, double oy, double *sx, double *sy) {
+static struct wlr_surface *layer_surface_at(struct wl_list *layer, double ox,
+                                             double oy, double *sx, double *sy)
+{
 	struct roots_layer_surface *roots_surface;
 
 	wl_list_for_each_reverse(roots_surface, layer, link) {
@@ -193,29 +195,27 @@ struct wlr_surface *desktop_surface_at(PhocDesktop *desktop,
 	struct wlr_surface *surface = NULL;
 	struct wlr_output *wlr_output =
 		wlr_output_layout_output_at(desktop->layout, lx, ly);
-	struct roots_output *roots_output = NULL;
+	PhocOutput *phoc_output = NULL;
 	double ox = lx, oy = ly;
 	if (view) {
 		*view = NULL;
 	}
 
 	if (wlr_output) {
-		roots_output = wlr_output->data;
+		phoc_output = wlr_output->data;
 		wlr_output_layout_output_coords(desktop->layout, wlr_output, &ox, &oy);
 
-		if ((surface = layer_surface_at(roots_output,
-					&roots_output->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY],
-					ox, oy, sx, sy))) {
+		if ((surface = layer_surface_at(&phoc_output->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY],
+						ox, oy, sx, sy))) {
 			return surface;
 		}
 
-		struct roots_output *output = wlr_output->data;
+		PhocOutput *output = wlr_output->data;
 		if (output != NULL && output->fullscreen_view != NULL) {
 
 			if (output->force_shell_reveal) {
-				if ((surface = layer_surface_at(roots_output,
-						&roots_output->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP],
-						ox, oy, sx, sy))) {
+				if ((surface = layer_surface_at(&phoc_output->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP],
+								ox, oy, sx, sy))) {
 					return surface;
 				}
 			}
@@ -230,9 +230,8 @@ struct wlr_surface *desktop_surface_at(PhocDesktop *desktop,
 			}
 		}
 
-		if ((surface = layer_surface_at(roots_output,
-					&roots_output->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP],
-					ox, oy, sx, sy))) {
+		if ((surface = layer_surface_at(&phoc_output->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP],
+						ox, oy, sx, sy))) {
 			return surface;
 		}
 	}
@@ -246,14 +245,12 @@ struct wlr_surface *desktop_surface_at(PhocDesktop *desktop,
 	}
 
 	if (wlr_output) {
-		if ((surface = layer_surface_at(roots_output,
-					&roots_output->layers[ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM],
-					ox, oy, sx, sy))) {
+		if ((surface = layer_surface_at(&phoc_output->layers[ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM],
+						ox, oy, sx, sy))) {
 			return surface;
 		}
-		if ((surface = layer_surface_at(roots_output,
-					&roots_output->layers[ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND],
-					ox, oy, sx, sy))) {
+		if ((surface = layer_surface_at(&phoc_output->layers[ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND],
+						ox, oy, sx, sy))) {
 			return surface;
 		}
 	}
@@ -268,7 +265,7 @@ handle_layout_change (struct wl_listener *listener, void *data)
   struct wlr_box *center_output_box;
   double center_x, center_y;
   struct roots_view *view;
-  struct roots_output *output;
+  PhocOutput *output;
 
   self = wl_container_of (listener, self, layout_change);
   center_output = wlr_output_layout_get_center_output (self->layout);
@@ -291,7 +288,7 @@ handle_layout_change (struct wl_listener *listener, void *data)
 
   /* Damage all outputs since the move above damaged old layout space */
   wl_list_for_each(output, &self->outputs, link)
-    output_damage_whole(output);
+    phoc_output_damage_whole(output);
 }
 
 static void input_inhibit_activate(struct wl_listener *listener, void *data) {
@@ -706,7 +703,7 @@ phoc_desktop_new (struct roots_config *config)
 void
 phoc_desktop_toggle_output_blank (PhocDesktop *self)
 {
-  struct roots_output *output;
+  PhocOutput *output;
 
   wl_list_for_each(output, &self->outputs, link) {
     gboolean enable = !output->wlr_output->enabled;
@@ -714,7 +711,7 @@ phoc_desktop_toggle_output_blank (PhocDesktop *self)
     wlr_output_enable (output->wlr_output, enable);
     wlr_output_commit (output->wlr_output);
     if (enable)
-      output_damage_whole(output);
+      phoc_output_damage_whole(output);
   }
 }
 
diff --git a/src/desktop.h b/src/desktop.h
index 7975de9..4aff94b 100644
--- a/src/desktop.h
+++ b/src/desktop.h
@@ -55,7 +55,7 @@ struct _PhocDesktop {
 
 	struct wl_list views; // roots_view::link
 
-	struct wl_list outputs; // roots_output::link
+	struct wl_list outputs; // PhocOutput::link
 	struct timespec last_frame;
 
 	struct roots_config *config;
diff --git a/src/layer_shell.c b/src/layer_shell.c
index 51f2695..653c803 100644
--- a/src/layer_shell.c
+++ b/src/layer_shell.c
@@ -242,7 +242,7 @@ static void change_osk(const struct osk_origin *osk, struct wl_list layers[LAYER
 	}
 }
 
-void arrange_layers(struct roots_output *output) {
+void arrange_layers(PhocOutput *output) {
 	struct wlr_box usable_area = { 0 };
 	PhocServer *server = phoc_server_get_default ();
 
@@ -345,7 +345,7 @@ static void handle_surface_commit(struct wl_listener *listener, void *data) {
 	struct wlr_layer_surface_v1 *layer_surface = layer->layer_surface;
 	struct wlr_output *wlr_output = layer_surface->output;
 	if (wlr_output != NULL) {
-		struct roots_output *output = wlr_output->data;
+		PhocOutput *output = wlr_output->data;
 		struct wlr_box old_geo = layer->geo;
 		arrange_layers(output);
 
@@ -372,13 +372,13 @@ static void handle_surface_commit(struct wl_listener *listener, void *data) {
 			layer->layer = layer_surface->current.layer;
 		}
 		if (geo_changed || layer_changed) {
-			output_damage_whole_local_surface(output, layer_surface->surface,
-					old_geo.x, old_geo.y);
-			output_damage_whole_local_surface(output, layer_surface->surface,
-					layer->geo.x, layer->geo.y);
+			phoc_output_damage_whole_local_surface(output, layer_surface->surface,
+							       old_geo.x, old_geo.y);
+			phoc_output_damage_whole_local_surface(output, layer_surface->surface,
+							       layer->geo.x, layer->geo.y);
 		} else {
-			output_damage_from_local_surface(output, layer_surface->surface,
-					layer->geo.x, layer->geo.y);
+			phoc_output_damage_from_local_surface(output, layer_surface->surface,
+							      layer->geo.x, layer->geo.y);
 		}
 	}
 }
@@ -387,8 +387,7 @@ static void unmap(struct wlr_layer_surface_v1 *layer_surface) {
 	struct roots_layer_surface *layer = layer_surface->data;
 	struct wlr_output *wlr_output = layer_surface->output;
 	if (wlr_output != NULL) {
-		struct roots_output *output = wlr_output->data;
-		output_damage_whole_local_surface(output, layer_surface->surface,
+		phoc_output_damage_whole_local_surface(wlr_output->data, layer_surface->surface,
 			layer->geo.x, layer->geo.y);
 	}
 }
@@ -406,7 +405,7 @@ static void handle_destroy(struct wl_listener *listener, void *data) {
 	wl_list_remove(&layer->surface_commit.link);
 	if (layer->layer_surface->output) {
 		wl_list_remove(&layer->output_destroy.link);
-		arrange_layers((struct roots_output *)layer->layer_surface->output->data);
+		arrange_layers((PhocOutput *)layer->layer_surface->output->data);
 	}
 	free(layer);
 }
@@ -434,7 +433,7 @@ static void popup_unconstrain(struct roots_layer_popup *popup) {
 	struct roots_layer_surface *layer = popup_get_root_layer(popup);
 	struct wlr_xdg_popup *wlr_popup = popup->wlr_popup;
 
-	struct roots_output *output = layer->layer_surface->output->data;
+	PhocOutput *output = layer->layer_surface->output->data;
 
 	// the output box expressed in the coordinate system of the toplevel parent
 	// of the popup
@@ -468,12 +467,12 @@ static void popup_damage(struct roots_layer_popup *layer_popup, bool whole) {
 	if (!wlr_output) {
 		return;
 	}
-	struct roots_output *output = wlr_output->data;
 
 	if (whole) {
-		output_damage_whole_local_surface(output, surface, ox, oy);
+		phoc_output_damage_whole_local_surface(wlr_output->data, surface, ox, oy);
 	} else {
-		output_damage_from_local_surface(output, surface, ox, oy);
+		phoc_output_damage_from_local_surface(layer->layer_surface->output->data,
+						      surface, ox, oy);
 	}
 }
 
@@ -599,15 +598,16 @@ static void subsurface_damage(struct roots_layer_subsurface *subsurface, bool wh
 	if (!wlr_output) {
 		return;
 	}
-	struct roots_output *output = wlr_output->data;
 	int ox = subsurface->wlr_subsurface->current.x + layer->geo.x;
 	int oy = subsurface->wlr_subsurface->current.y + layer->geo.y;
 	if (whole) {
-		output_damage_whole_local_surface(output, subsurface->wlr_subsurface->surface,
-			ox, oy);
+		phoc_output_damage_whole_local_surface(wlr_output->data,
+						       subsurface->wlr_subsurface->surface,
+						       ox, oy);
 	} else {
-		output_damage_from_local_surface(output, subsurface->wlr_subsurface->surface,
-			ox, oy);
+		phoc_output_damage_from_local_surface(wlr_output->data,
+						      subsurface->wlr_subsurface->surface,
+						      ox, oy);
 	}
 }
 
@@ -718,9 +718,9 @@ static void handle_map(struct wl_listener *listener, void *data) {
 	layer->new_subsurface.notify = handle_new_subsurface;
 	wl_signal_add(&layer_surface->surface->events.new_subsurface, &layer->new_subsurface);
 
-	struct roots_output *output = wlr_output->data;
-	output_damage_whole_local_surface(output, layer_surface->surface,
-		layer->geo.x, layer->geo.y);
+	phoc_output_damage_whole_local_surface(wlr_output->data,
+					       layer_surface->surface, layer->geo.x,
+					       layer->geo.y);
 	wlr_surface_send_enter(layer_surface->surface, wlr_output);
 }
 
@@ -806,7 +806,7 @@ void handle_layer_shell_surface(struct wl_listener *listener, void *data) {
 	roots_surface->layer_surface = layer_surface;
 	layer_surface->data = roots_surface;
 
-	struct roots_output *output = layer_surface->output->data;
+	PhocOutput *output = layer_surface->output->data;
 	wl_list_insert(&output->layers[layer_surface->client_pending.layer], &roots_surface->link);
 
 	// Temporarily set the layer's current state to client_pending
diff --git a/src/layers.h b/src/layers.h
index a9afdaa..adb7294 100644
--- a/src/layers.h
+++ b/src/layers.h
@@ -4,6 +4,7 @@
 #include <wlr/types/wlr_box.h>
 #include <wlr/types/wlr_surface.h>
 #include <wlr/types/wlr_layer_shell_v1.h>
+#include "output.h"
 
 enum layer_parent {
 	LAYER_PARENT_LAYER,
@@ -63,8 +64,6 @@ struct roots_layer_subsurface {
 	struct wl_list subsurfaces; // roots_layer_subsurface::link
 };
 
-
-struct roots_output;
-void arrange_layers(struct roots_output *output);
+void arrange_layers(PhocOutput *output);
 
 #endif
diff --git a/src/render.c b/src/render.c
index f5c514b..5784309 100644
--- a/src/render.c
+++ b/src/render.c
@@ -101,7 +101,7 @@ buffer_damage_finish:
 }
 
 static void
-collect_touch_points (struct roots_output *output, struct wlr_surface *surface, struct wlr_box box, float scale)
+collect_touch_points (PhocOutput *output, struct wlr_surface *surface, struct wlr_box box, float scale)
 {
   PhocServer *server = phoc_server_get_default ();
   if (G_LIKELY (!(server->debug_flags & PHOC_SERVER_DEBUG_FLAG_TOUCH_POINTS))) {
@@ -122,7 +122,7 @@ collect_touch_points (struct roots_output *output, struct wlr_surface *surface,
   }
 }
 
-static void render_surface_iterator(struct roots_output *output,
+static void render_surface_iterator(PhocOutput *output,
 		struct wlr_surface *surface, struct wlr_box *_box, float rotation,
 		float scale, void *_data) {
 	struct render_data *data = _data;
@@ -136,8 +136,8 @@ static void render_surface_iterator(struct roots_output *output,
 	}
 
 	struct wlr_box box = *_box;
-	scale_box(&box, scale);
-	scale_box(&box, wlr_output->scale);
+	phoc_output_scale_box(wlr_output->data, &box, scale);
+	phoc_output_scale_box(wlr_output->data, &box, wlr_output->scale);
 
 	float matrix[9];
 	enum wl_output_transform transform =
@@ -154,7 +154,7 @@ static void render_surface_iterator(struct roots_output *output,
 	collect_touch_points(output, surface, box, scale);
 }
 
-static void render_decorations(struct roots_output *output,
+static void render_decorations(PhocOutput *output,
 		struct roots_view *view, struct render_data *data) {
 	if (!view->decorated || view->wlr_surface == NULL) {
 		return;
@@ -165,7 +165,7 @@ static void render_decorations(struct roots_output *output,
 	assert(renderer);
 
 	struct wlr_box box;
-	get_decoration_box(view, output, &box);
+	phoc_output_get_decoration_box(output, view, &box);
 
 	struct wlr_box rotated;
 	wlr_box_rotated_bounds(&rotated, &box, view->rotation);
@@ -197,7 +197,7 @@ buffer_damage_finish:
 	pixman_region32_fini(&damage);
 }
 
-static void render_view(struct roots_output *output, struct roots_view *view,
+static void render_view(PhocOutput *output, struct roots_view *view,
 		struct render_data *data) {
 	// Do not render views fullscreened on other outputs
 	if (view->fullscreen_output != NULL && view->fullscreen_output != output) {
@@ -208,27 +208,27 @@ static void render_view(struct roots_output *output, struct roots_view *view,
 	if (view->fullscreen_output == NULL) {
 		render_decorations(output, view, data);
 	}
-	output_view_for_each_surface(output, view, render_surface_iterator, data);
+	phoc_output_view_for_each_surface(output, view, render_surface_iterator, data);
 }
 
-static void render_layer(struct roots_output *output,
+static void render_layer(PhocOutput *output,
 		pixman_region32_t *damage, struct wl_list *layer_surfaces) {
 	struct render_data data = {
 		.damage = damage,
 		.alpha = 1.0f,
 	};
-	output_layer_for_each_surface(output, layer_surfaces,
+	phoc_output_layer_for_each_surface(output, layer_surfaces,
 		render_surface_iterator, &data);
 }
 
-static void count_surface_iterator(struct roots_output *output,
+static void count_surface_iterator(PhocOutput *output,
 		struct wlr_surface *surface, struct wlr_box *_box, float rotation,
 		float scale, void *data) {
 	size_t *n = data;
 	n++;
 }
 
-static bool scan_out_fullscreen_view(struct roots_output *output) {
+static bool scan_out_fullscreen_view(PhocOutput *output) {
 	struct wlr_output *wlr_output = output->wlr_output;
 	PhocServer *server = phoc_server_get_default ();
 
@@ -258,7 +258,7 @@ static bool scan_out_fullscreen_view(struct roots_output *output) {
 		return false;
 	}
 	size_t n_surfaces = 0;
-	output_view_for_each_surface(output, view,
+	phoc_output_view_for_each_surface(output, view,
 		count_surface_iterator, &n_surfaces);
 	if (n_surfaces > 1) {
 		return false;
@@ -297,13 +297,13 @@ static bool scan_out_fullscreen_view(struct roots_output *output) {
 	return wlr_output_commit(wlr_output);
 }
 
-static void render_drag_icons(struct roots_output *output,
+static void render_drag_icons(PhocOutput *output,
 		pixman_region32_t *damage, PhocInput *input) {
 	struct render_data data = {
 		.damage = damage,
 		.alpha = 1.0f,
 	};
-	output_drag_icons_for_each_surface(output, input,
+	phoc_output_drag_icons_for_each_surface(output, input,
 		render_surface_iterator, &data);
 }
 
@@ -348,7 +348,7 @@ render_touch_point_cb (gpointer data, gpointer user_data)
 {
   struct touch_point_data *touch_point = data;
 
-  struct roots_output *output = user_data;
+  PhocOutput *output = user_data;
   struct wlr_output *wlr_output = output->wlr_output;
 
   struct wlr_box point_box = wlr_box_from_touch_point (touch_point, TOUCH_POINT_RADIUS * wlr_output->scale);
@@ -364,7 +364,7 @@ render_touch_point_cb (gpointer data, gpointer user_data)
 }
 
 static void
-render_touch_points (struct roots_output *output)
+render_touch_points (PhocOutput *output)
 {
   PhocServer *server = phoc_server_get_default ();
   if (G_LIKELY (!(server->debug_flags & PHOC_SERVER_DEBUG_FLAG_TOUCH_POINTS))) {
@@ -378,7 +378,7 @@ damage_touch_point_cb (gpointer data, gpointer user_data)
 {
   struct touch_point_data *touch_point = data;
 
-  struct roots_output *output = user_data;
+  PhocOutput *output = user_data;
   struct wlr_output *wlr_output = output->wlr_output;
 
   struct wlr_box box = wlr_box_from_touch_point (touch_point, TOUCH_POINT_RADIUS * wlr_output->scale);
@@ -389,7 +389,7 @@ damage_touch_point_cb (gpointer data, gpointer user_data)
 }
 
 static void
-damage_touch_points (struct roots_output *output)
+damage_touch_points (PhocOutput *output)
 {
   if (!g_list_length (output->debug_touch_points)) {
     return;
@@ -473,14 +473,14 @@ view_render_to_buffer (struct roots_view *view, int width, int height, int strid
   return TRUE;
 }
 
-static void surface_send_frame_done_iterator(struct roots_output *output,
+static void surface_send_frame_done_iterator(PhocOutput *output,
 		struct wlr_surface *surface, struct wlr_box *box, float rotation,
 		float scale, void *data) {
 	struct timespec *when = data;
 	wlr_surface_send_frame_done(surface, when);
 }
 
-void output_render(struct roots_output *output) {
+void output_render(PhocOutput *output) {
 	struct wlr_output *wlr_output = output->wlr_output;
 	PhocDesktop *desktop = output->desktop;
 	PhocServer *server = phoc_server_get_default ();
@@ -592,7 +592,7 @@ void output_render(struct roots_output *output) {
 		if (view->type == ROOTS_XWAYLAND_VIEW) {
 			struct roots_xwayland_surface *xwayland_surface =
 				roots_xwayland_surface_from_view(view);
-			output_xwayland_children_for_each_surface(output,
+			phoc_output_xwayland_children_for_each_surface(output,
 				xwayland_surface->xwayland_surface,
 				render_surface_iterator, &data);
 		}
@@ -678,7 +678,7 @@ buffer_damage_finish:
 
 send_frame_done:
 	// Send frame done events to all surfaces
-	output_for_each_surface(output, surface_send_frame_done_iterator, &now);
+	phoc_output_for_each_surface(output, surface_send_frame_done_iterator, &now);
 
 	damage_touch_points(output);
 	g_list_free_full(output->debug_touch_points, g_free);
diff --git a/src/render.h b/src/render.h
index 0556680..92508b1 100644
--- a/src/render.h
+++ b/src/render.h
@@ -7,5 +7,5 @@
 
 #include "output.h"
 
-void output_render(struct roots_output *output);
+void output_render(PhocOutput *output);
 gboolean view_render_to_buffer (struct roots_view *view, int width, int height, int stride, uint32_t *flags, void* data);
diff --git a/src/seat.c b/src/seat.c
index e76bcf1..0acc0ee 100644
--- a/src/seat.c
+++ b/src/seat.c
@@ -435,7 +435,7 @@ static void seat_reset_device_mappings(struct roots_seat *seat,
 }
 
 static void seat_set_device_output_mappings(struct roots_seat *seat,
-		struct wlr_input_device *device, struct roots_output *output) {
+		struct wlr_input_device *device, PhocOutput *output) {
 	struct wlr_cursor *cursor = seat->cursor->cursor;
 
 	switch (device->type) {
@@ -463,7 +463,7 @@ void roots_seat_configure_cursor(struct roots_seat *seat) {
 	struct roots_pointer *pointer;
 	PhocTouch *touch;
 	struct roots_tablet *tablet;
-	struct roots_output *output;
+	PhocOutput *output;
 
 	// reset mappings
 	wlr_cursor_map_to_output(cursor, NULL);
@@ -717,10 +717,10 @@ void roots_drag_icon_update_position(struct roots_drag_icon *icon) {
 
 void roots_drag_icon_damage_whole(struct roots_drag_icon *icon) {
 	PhocServer *server = phoc_server_get_default ();
-	struct roots_output *output;
+	PhocOutput *output;
 	wl_list_for_each(output, &server->desktop->outputs,
 			link) {
-		output_damage_whole_drag_icon(output, icon);
+		phoc_output_damage_whole_drag_icon(output, icon);
 	}
 }
 
@@ -1191,7 +1191,7 @@ void roots_seat_configure_xcursor(struct roots_seat *seat) {
 		}
 	}
 
-	struct roots_output *output;
+	PhocOutput *output;
 	wl_list_for_each(output, &server->desktop->outputs, link) {
 		float scale = output->wlr_output->scale;
 #if (WLR_VERSION_MAJOR > 0 || WLR_VERSION_MINOR > 10)
@@ -1370,7 +1370,7 @@ void roots_seat_set_focus(struct roots_seat *seat, struct roots_view *view) {
 
 	if (view && unfullscreen) {
 		PhocDesktop *desktop = view->desktop;
-		struct roots_output *output;
+		PhocOutput *output;
 		struct wlr_box box;
 		view_get_box(view, &box);
 		wl_list_for_each(output, &desktop->outputs, link) {
@@ -1517,7 +1517,7 @@ void roots_seat_set_exclusive_client(struct roots_seat *seat,
 		seat->exclusive_client = client;
 		// Triggers a refocus of the topmost surface layer if necessary
 		// TODO: Make layer surface focus per-output based on cursor position
-		struct roots_output *output;
+		PhocOutput *output;
 		wl_list_for_each(output, &server->desktop->outputs, link) {
 			arrange_layers(output);
 		}
diff --git a/src/view.c b/src/view.c
index 9db62ad..92edfce 100644
--- a/src/view.c
+++ b/src/view.c
@@ -164,7 +164,7 @@ static void view_update_output(struct roots_view *view,
 	struct wlr_box box;
 	view_get_box(view, &box);
 
-	struct roots_output *output;
+	PhocOutput *output;
 	wl_list_for_each(output, &desktop->outputs, link) {
 		bool intersected = before != NULL && wlr_output_layout_intersects(
 			desktop->layout, output->wlr_output, before);
@@ -274,11 +274,11 @@ void view_arrange_maximized(struct roots_view *view) {
 		return;
 	}
 
-	struct roots_output *roots_output = output->data;
+	PhocOutput *phoc_output = output->data;
 	struct wlr_box *output_box =
 		wlr_output_layout_get_box(view->desktop->layout, output);
 	struct wlr_box usable_area;
-	memcpy(&usable_area, &roots_output->usable_area,
+	memcpy(&usable_area, &phoc_output->usable_area,
 			sizeof(struct wlr_box));
 	usable_area.x += output_box->x;
 	usable_area.y += output_box->y;
@@ -378,8 +378,8 @@ void view_set_fullscreen(struct roots_view *view, bool fullscreen,
 		if (output == NULL) {
 			output = view_get_output(view);
 		}
-		struct roots_output *roots_output = output->data;
-		if (roots_output == NULL) {
+		PhocOutput *phoc_output = output->data;
+		if (phoc_output == NULL) {
 			return;
 		}
 
@@ -402,10 +402,10 @@ void view_set_fullscreen(struct roots_view *view, bool fullscreen,
 			output_box->height);
 		view_rotate(view, 0);
 
-		roots_output->fullscreen_view = view;
-		roots_output->force_shell_reveal = false;
-		view->fullscreen_output = roots_output;
-		output_damage_whole(roots_output);
+		phoc_output->fullscreen_view = view;
+		phoc_output->force_shell_reveal = false;
+		view->fullscreen_output = phoc_output;
+		phoc_output_damage_whole(phoc_output);
 	}
 
 	if (was_fullscreen && !fullscreen) {
@@ -413,7 +413,7 @@ void view_set_fullscreen(struct roots_view *view, bool fullscreen,
 			view->saved.height);
 		view_rotate(view, view->saved.rotation);
 
-		output_damage_whole(view->fullscreen_output);
+		phoc_output_damage_whole(view->fullscreen_output);
 		view->fullscreen_output->fullscreen_view = NULL;
 		view->fullscreen_output = NULL;
 
@@ -443,7 +443,7 @@ view_move_to_next_output (struct roots_view *view, enum wlr_direction direction)
   PhocDesktop *desktop = view->desktop;
   struct wlr_output_layout *layout = view->desktop->layout;
   const struct wlr_output_layout_output *l_output;
-  struct roots_output *roots_output;
+  PhocOutput *phoc_output;
   struct wlr_output *output, *new_output;
   struct wlr_box usable_area;
   double x, y;
@@ -461,8 +461,8 @@ view_move_to_next_output (struct roots_view *view, enum wlr_direction direction)
   if (!new_output)
     return false;
 
-  roots_output = new_output->data;
-  memcpy(&usable_area, &roots_output->usable_area, sizeof(struct wlr_box));
+  phoc_output = new_output->data;
+  memcpy(&usable_area, &phoc_output->usable_area, sizeof(struct wlr_box));
   l_output = wlr_output_layout_get(desktop->layout, new_output);
 
   /* use a proper position on the new output */
@@ -486,7 +486,7 @@ void
 view_tile(struct roots_view *view, PhocViewTileDirection direction)
 {
   struct wlr_output *output = view_get_output(view);
-  struct roots_output *roots_output = output->data;
+  PhocOutput *phoc_output = output->data;
   struct wlr_box *output_box =
     wlr_output_layout_get_box(view->desktop->layout, output);
   struct wlr_box usable_area;
@@ -511,7 +511,7 @@ view_tile(struct roots_view *view, PhocViewTileDirection direction)
   view->saved.width = view->box.width;
   view->saved.height = view->box.height;
 
-  memcpy(&usable_area, &roots_output->usable_area,
+  memcpy(&usable_area, &phoc_output->usable_area,
 	 sizeof(struct wlr_box));
   usable_area.x += output_box->x;
   usable_area.y += output_box->y;
@@ -564,9 +564,9 @@ bool view_center(struct roots_view *view) {
 		wlr_output_layout_get(desktop->layout, output);
 
 	struct wlr_box usable_area;
-	struct roots_output *roots_output = output->data;
+	PhocOutput *phoc_output = output->data;
 
-	memcpy(&usable_area, &roots_output->usable_area, sizeof(struct wlr_box));
+	memcpy(&usable_area, &phoc_output->usable_area, sizeof(struct wlr_box));
 
 	double view_x = (double)(usable_area.width - box.width) / 2 +
 	  usable_area.x + l_output->x - geom.x * view->scale;
@@ -651,7 +651,7 @@ static void subsurface_handle_map(struct wl_listener *listener,
 
 	struct wlr_box box;
 	view_get_box(view, &box);
-	struct roots_output *output;
+	PhocOutput *output;
 	wl_list_for_each(output, &view->desktop->outputs, link) {
 		bool intersects = wlr_output_layout_intersects(view->desktop->layout,
 			output->wlr_output, &box);
@@ -740,11 +740,11 @@ static void view_update_scale(struct roots_view *view) {
 		return;
 	}
 
-	struct roots_output *roots_output = output->data;
+	PhocOutput *phoc_output = output->data;
 
 	float scalex = 1.0f, scaley = 1.0f, oldscale = view->scale;
-	scalex = roots_output->usable_area.width / (float)view->box.width;
-	scaley = roots_output->usable_area.height / (float)view->box.height;
+	scalex = phoc_output->usable_area.width / (float)view->box.width;
+	scaley = phoc_output->usable_area.height / (float)view->box.height;
 	if (scaley < scalex) {
 		view->scale = scaley;
 	} else {
@@ -802,7 +802,7 @@ void view_unmap(struct roots_view *view) {
 	}
 
 	if (view->fullscreen_output != NULL) {
-		output_damage_whole(view->fullscreen_output);
+		phoc_output_damage_whole(view->fullscreen_output);
 		view->fullscreen_output->fullscreen_view = NULL;
 		view->fullscreen_output = NULL;
 	}
@@ -850,16 +850,16 @@ void view_setup(struct roots_view *view) {
 }
 
 void view_apply_damage(struct roots_view *view) {
-	struct roots_output *output;
+	PhocOutput *output;
 	wl_list_for_each(output, &view->desktop->outputs, link) {
-		output_damage_from_view(output, view);
+		phoc_output_damage_from_view(output, view);
 	}
 }
 
 void view_damage_whole(struct roots_view *view) {
-	struct roots_output *output;
+	PhocOutput *output;
 	wl_list_for_each(output, &view->desktop->outputs, link) {
-		output_damage_whole_view(output, view);
+		phoc_output_damage_whole_view(output, view);
 	}
 }
 
diff --git a/src/view.h b/src/view.h
index b490c4e..bc079df 100644
--- a/src/view.h
+++ b/src/view.h
@@ -11,6 +11,8 @@
 #include <wlr/types/wlr_xdg_decoration_v1.h>
 #include <wlr/types/wlr_xdg_shell.h>
 
+#include "output.h"
+
 struct roots_view;
 
 struct roots_view_interface {
@@ -68,7 +70,7 @@ struct roots_view {
 	char *app_id;
 
 	PhocViewState state;
-	struct roots_output *fullscreen_output;
+	PhocOutput *fullscreen_output;
 	struct {
 		PhocViewState state;
 		double x, y;
-- 
2.26.2

